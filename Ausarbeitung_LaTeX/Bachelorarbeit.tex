%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------ LaTeX-Template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%---- Header (mit Formateinstellugen) laden, Inputencoding prüfen ------

\input{header}

%\usepackage[applemac]{inputenc} % Inputencoding fï¿½r Mac
%\usepackage[latin1]{inputenc} % Inputencoding fï¿½r PC/Win
\usepackage[utf8]{inputenc} % Inputencoding, universell
%\usepackage[utf8x]{inputenc} % Inputencoding, universell


%------------------------ Titelblatt-Layout laden ----------------------------------

\input{titelblatt}

%---------------------------- Titeldefinitionen --------------------------------------

\newcommand{\vorname}{Sebastian}
\newcommand{\nachname}{Bohn}
\newcommand{\matrikelnummer}{2036605}

\newcommand{\titel}{Analyse und Evaluierung von plattformübergreifenden Spiel-Engines und Frameworks, anhand der Implementierung einer mobilen Beispielapplikation}

\newcommand{\erstpruef}{Prof. Dr. Edmund Weitz}
\newcommand{\zweitpruef}{Prof. Dr. Andreas Plaß}

%\date{vorläufige Fassung vom \today}   % Vorab-Version 
\date{\sffamily Hamburg, 29. 02. 2016}  % Abgabedatum!

%----------------------------- ANFANG --------------------------------------

\begin{document}
\selectlanguage{ngerman}
\setlength{\parindent}{0em}
% Titelseite erzeugen
\maketitle

%---------------------------ABSTRACT------------------------------------
\onehalfspacing
\thispagestyle{empty}
\selectlanguage{english}
\section*{\centering\abstractname}
The market of mobile devices such as smartphones and tablets regularly improves its technological standards and experiences a continuous growth for years. Due to high usability, mobile devices enjoy great popularity among all kind of consumers. Through the broad quantity of users with high-performance mobile computers, digital games are earning greater popularity than ever. The category Games dominates the amount of downloads of the application stores in all leading systems. In order to meet the demands of users with different systems in an economical way, developers require efficient tools for game development. At first, these special frameworks and engines for cross-platform game development are reviewed by their specifications, followed by the implementation of an example application. The theoretical and practical gained knowledge and the conclusive comparison reveal, that the choice of the right development tool still largely depends on the requirements. Nevertheless, Unity3D still clearly dominates its competitors in most disciplines and stands out as an all-rounder in game development. 


\selectlanguage{ngerman}
\section*{\centering\abstractname}
Der Markt für mobile Geräte wie Smartphones und Tablets erfährt seit Jahren kontinuierliches Wachstum und übertrifft regelmäßig seine technologischen Standards. Durch die hohe Benutzerfreundlichkeit erfreuen sich mobile Geräte großer Beliebtheit innerhalb aller Verbraucherschichten. Aufgrund der breiten Masse an Nutzern von performanten, mobilen Computern gewinnen auch digitale Spiele immer größere Popularität. Die Spielekategorie dominiert die Downloadzahlen der Stores für Applikationen in allen führenden Systemen. Um die Nachfrage für Nutzer unterschiedlicher Systeme auf ökonomische Weise decken zu können, bedarf es entwicklerseitig effizienter Werkzeuge zur Spieleentwicklung.
Diese besonderen Frameworks und Engines für die plattformübergreifende Spieleentwicklung werden zunächst aufgrund ihrer Spezifikation begutachtet und daraufhin durch die Implementierung einer Beispielapplikation praktisch angewandt. Durch die gewonnenen theoretischen und praktischen Erkenntnisse und den abschließenden Vergleich kann evaluiert werden, dass die Wahl des passenden Entwicklungstools primär in Abhängigkeit zu der gestellten Anforderung steht. Jedoch kann Unity3D in den meisten Disziplinen seine Konkurrenz klar dominieren und nahezu als Alleskönner der Spieleentwicklung hervorgehoben werden.





% Inhaltsverzeichnis erzeugen          
\tableofcontents
% Seitenumbruch
\clearpage

%----------------------------INHALT---------------------------------------


%----------------------------TEXT-----------------------------------------------

\chapter{Einleitung}

\section{Motivation}
%TODO: Seiten, Abbildungen und Textsprünge überprüfen
Digitale Spiele sind ein Zeitvertreib, der spätestens seit der Verbreitung von Smartphones in der modernen Bevölkerung bei allen Altersgruppen und Gesellschaftsschichten Einzug gehalten hat. Mobile Betriebssysteme bieten somit Plattformen, die eine breite Nutzergruppe erreichbar macht. Die Uneinheitlichkeit dieser Systeme erweckt das entwicklerseitige Bedürfnis nach Softwareinstrumenten, die plattformübergreifende Entwicklung ermöglicht. Der Einsatz dieser speziellen Entwicklungswerkzeuge rechtfertigt sich durch höhere Entwicklungsgeschwindigkeit und geringere Entwicklungskosten.

\bigskip
Gerade im Bereich der Spieleentwicklung besteht ein vielfältiges Angebot von plattformübergreifenden Frameworks und Engines, was die Wahl nach einer passenden Software nicht trivial erscheinen lässt. Demnach stellt sich die Frage, von welchen Faktoren eine geeignete Auswahl abhängt:

\begin{itemize}
	\item Welche mobile Plattformen besitzen das höchste, wirtschaftliche Potential und bedienen die größte Zielgruppe?
	\item Welche Entwicklungswerkzeuge unterstützen diese erfolgreichen Plattformen gleichzeitig?
	\item Womit können die inhaltlichen und funktionalen Anforderungen am effektivsten erfüllt werden?
\end{itemize}

Diese grundlegenden Fragestellungen geben Anlass, ausgewählte Spieleframeworks anhand ihrer theoretischen Möglichkeiten zu analysieren und durch die Entwicklung einer Beispielapplikation zu evaluieren. Um ein besseres Verständnis von plattformübergreifender Entwicklung zu gewinnen, soll weiterhin die Arbeitsweise dieses Prinzips näher betrachtet und mögliche Unterschiede ausgemacht werden. Durch die Bearbeitung soll ermittelt werden, welche Software am besten zu den gestellten Anforderungen passt, welche Schwächen ausfindig gemacht werden können und ob es eine eventuelle Allzwecklösung gibt.

\section{Gliederung}
Die Thesis \emph{„Analyse und Evaluierung von plattformübergreifenden Spiel-Engines und Frameworks, anhand der Implementierung einer mobilen Beispielapplikation“} ist in zehn Kapitel unterteilt, die das Thema systematisch aufbauen und analysieren.

\bigskip
Im ersten Kapitel wird die Motivation für diese Arbeit begründet sowie die Gliederung für die Vorgehensweise beschrieben.

\bigskip
Das zweite Kapitel analysiert die aktuelle Marktsituation des mobilen Sektors, um die meist genutzten Systeme zu ermitteln. Daraufhin wird durch Statistiken das Verhältnis der Downloads an mobilen Spielen gegenüber anderen Kategorien ermittelt. Weiterhin werden die Spezifikationen der mobilen Betriebssysteme betrachtet und verglichen. 

\bigskip
Das dritte Kapitel befasst sich mit der nativen Softwareentwicklung von Android, iOS und Windows Phone. Dabei werden die Voraussetzungen, Notwendigkeiten und Möglichkeiten dargelegt.

\bigskip
Die Aspekte der plattformübergreifenden Entwicklung werden im vierten Kapitel behandelt. Dabei werden die generellen Ziele genannt und die verschiedenen Ansätze zur Umsetzung erläutert. 

\bigskip
Im fünften Kapitel werden plattformübergreifende Werkzeuge zur Spieleentwicklung betrachtet. Dafür werden Anforderungen definiert, um Tools zu bestimmen, die vergleichbare Eigenschaften für die Entwicklung mobiler Spiele besitzen. Die ausgewählten Werkzeuge werden daraufhin vorgestellt.

\bigskip
Das sechste Kapitel analysiert die spezifischen Eigenschaften der Spieleframeworks. Es zeigt die erreichbaren Zielplattformen, die nutzbaren Programmiersprachen, Entwicklungsumgebungen sowie die Schnittstellen für native Gerätefunktionen und Game Services auf. Als letztes werden eventuelle Produktvarianten aufgelistet.

\bigskip
Die Konzeption und darauf folgende Implementierung der Beispielapplikation sind Thema des siebten Kapitels. Dafür werden zuerst Anforderungen an ein beispielhaftes, mobiles Spiel definiert. Danach wird die gewählte Spielidee und der Spielfluss erklärt. Weiterhin werden die verwendeten Betriebssysteme, Werkzeuge und Versionen aufgelistet. Danach werden die eingesetzten Spiellemente und ihre Verwendung erklärt.

\bigskip
Im achten Kapitel werden die erzeugten Applikationen analysiert. Dafür werden als Erstes messbare Metriken definiert, um die Anwendungen vergleichbar zu machen. Danach werden die genutzten Testgeräte und die vorgenommenen Grundeinstellungen aufgezeigt. Die Messprotokolle mit den dokumentierten Ergebnissen werden im letzten Teil aufgelistet.

\bigskip
Das neunte Kapitel befasst sich mit dem Vergleich der gewonnenen Erkenntnisse aus den Analysen der Messresultate und des Entwicklungsprozesses sowie mit einer Empfehlung zur Benutzbarkeit der Spieleframeworks.

\bigskip
Das finale Kapitel gibt ein abschließendes Fazit zu der gesamten Arbeit ab.

%Kapitel 2
\chapter{Mobile Systeme}

\section{Marktanalyse zur Gewichtung der mobilen Systeme und der Applikationen}
Welche mobilen Systeme derzeit am Gefragtesten und Verbreitetsten sind, soll in diesem Abschnitt analysiert werden. Dieses Wissen ist nötig, um vor dem Entwicklungsprozess die aktuell erfolgreichsten und zukünftig erfolgversprechendsten Plattformen auszuwählen und miteinzubeziehen.
Weiterhin soll geklärt werden, wie viele Applikationen diese Plattformen in ihren Stores bereitstellen und wie die Kategorien gewichtet sind.

\subsection{Marktanteile der mobilen Betriebssysteme}
\label{subsec:Marktanteile_mobile_Systeme}
Eine Statistik über die Marktanteile der mobilen Betriebssysteme bei Smartphones soll veranschaulichen, welche Systeme aktuell zu den Führenden gehören. Zusätzlich wird eine zukünftige Verteilung prognostiziert. Die Darstellungen beziehen sich auf Daten der International Data Corporation (IDC) über den globalen Absatz von Smartphones und wurde im August 2015 veröffentlicht (vgl. Abb. \ref{graph_mobile_systems}). 

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Bilder/Marktanteile_Betriebssysteme}
	\caption{Prognose zu den Marktanteilen der Betriebssysteme am weltweiten Absatz von Smartphones, in den Jahren 2015 und 2019}\label{graph_mobile_systems}\citep{marktanteile_betriebssysteme}
\end{figure}

Die Grafik verdeutlicht, dass Geräte mit Android Systemen den Markt eindeutig dominieren, direkt gefolgt von iOS und Windows Phone. Laut Prognose wird sich auch in den nächsten Jahren an dieser Hierarchie nichts ändern.
Abbildung \ref{graph_mobile_systems_laender} gibt weiteren Aufschluss über die Verteilung der Systeme nach ausgewählten Ländern. Die Daten beziehen sich auf die Verkäufe von August bis Oktober 2015, welche von Kantar \citep{marktanteile_betriebssysteme_laender} im Dezember 2015 veröffentlicht wurden. 
Man kann anhand der Daten schlussfolgern, dass Android und iOS derzeit die beiden relevantesten Systeme auf dem mobilen Markt sind. Mit deutlich geringeren Nutzerzahlen steht Windows Phone an dritter Stelle. 

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Marktanteile_nach_Laendern}
	\caption{Marktanteile der mobilen Betriebssysteme am Absatz von Smartphones in ausgewählten Ländern, von August bis Oktober 2015}\label{graph_mobile_systems_laender}\citep{marktanteile_betriebssysteme_laender}
\end{figure}

\subsection{Verfügbare Applikationen und Kategorien der Stores}
Die Menge an verfügbaren Apps in den jeweiligen Stores ist unterschiedlich groß.
Eine Analyse der aktiven Applikationen in den einzelnen Stores und die Gewichtung der Kategorien soll einen Überblick darüber geben, was die jeweiligen Plattformen aktuell zu bieten haben.
In Abbildung \ref{graph_apps_in_stores} wird die Gesamtquantität der Apps für Mai 2015 dargestellt. Um eine bessere Übersicht zu gewährleisten, wurden die Werte auf Zehntausend gerundet. Zu erwähnen ist, dass der Amazon Appstore, genau wie der Google Play Store, nur Android Apps anbietet. Da es in diesen beiden Stores zu Überschneidungen des Angebots von Anwendungen kommt, werden diese Werte separat betrachtet und nicht summiert.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Anzahl_der_Apps}
	\caption{Anzahl der angebotenen Apps in den Top App-Stores im Mai 2015}\label{graph_apps_in_stores}\citep{apps_in_stores}
\end{figure}

Der angegebene Wert für den Windows Phone Store ist laut der Quelle von September 2014 und schließt damit noch nicht die Windows 10 Universal Apps mit ein. Diese erschienen erst Mitte 2015, sollen für jedwede Windows 10 Hardware verfügbar sein und werden in einem separaten Windows Store angeboten. Im September 2015 waren rund 80\% der Downloads aus dem Windows Phone Store von Geräten mit der Version 8.1, etwa 15\% von 8.0 Benutzern und etwa 5\% von der alternden Version 7.8.
Laut Microsoft wurden im September 2015 etwa 50\% der Applikationen mit Windows 10 aus dem neuen Windows Store heruntergeladen. Diese Statistik gibt jedoch wenig Aufschluss darüber, wie groß dabei der Anteil an mobilen Systemen ist. Jedoch dominiert die Kategorie Games bei Windows 10 Apps die Downloadzahlen mit fast 45\% \citep{windows_store_trends_2015}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Bilder/Google_Play_Store_Kategorien}
	\caption{Aufteilung der weltweit am häufigsten heruntergeladenen Kategorien im Google Play Store, im Februar 2014 (Werte in Prozent)}\label{graph_play_store_kategorien}\citep{play_store_categories}
\end{figure}

Auch im Google Play Store werden Spiele am häufigsten heruntergeladen und nehmen etwa 41\% des Downloadvolumens ein(vgl. Abb. \ref{graph_play_store_kategorien}).

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Top_Kategorien_App_Store}
	\caption{Downloadzahlen der Top-Kategorien des Apple App Stores, für Dezember 2015 (Werte in Prozent)}\label{graph_app_store_kategorien}\citep{app_store_categories}
\end{figure}

Die beliebtesten Kategorien des Apple App Store werden ebenfalls deutlich von den Spielen angeführt. Auch wenn der Abstand zur zweithäufigsten Kategorie geringer ist als bei den anderen Stores, macht der Spielebereich trotzdem etwa ein Viertel aller Downloads aus (vgl. Abb. \ref{graph_app_store_kategorien}).

\bigskip
Obwohl jeder digitale Marktplatz seine Applikationen auf eigene Weise kategorisiert, ist dennoch klar zu erkennen, dass Spiele bei jedem Anbieter das höchste Downloadvolumen ausmachen und sich stetig wachsender Beliebtheit erfreuen. Die Nachfrage nach mobilen Spielen ist demnach plattformübergreifend und berechtigt die Evaluierung entsprechender Entwicklungssoftware.

\section{Betrachtung der mobilen Systeme}
Die gewonnenen Erkenntnisse aus Kapitel \ref{subsec:Marktanteile_mobile_Systeme} zeigen, dass derzeit die mobilen Systeme von Android, iOS und Windows Phone die größte Rolle bei den Verbrauchern spielen. Folglich werden im weiteren Verlauf andere Systeme nicht weiter berücksichtigt, so dass der Fokus auf diese drei Systeme gerichtet wird.

\subsection{Android}
Android ist ein Open Source Betriebssystem und gleichzeitig eine Software-Plattform, welche stark im mobilen Bereich vertreten ist und auf dem Linux-Kernel basiert. Zu finden ist Android auf Smartphones, Tablets, Netbooks und auf Smart-TV Geräten. \citep{android_overview} Entwickelt wird Android von der Open Handset Alliance (OHA), welche im November 2007 von Google gegründet wurde. Die OHA ist ein Konsortium von mehr als 80 Unternehmen aus den Bereichen Mobilfunknetz, Geräteherstellung, Halbleiterindustrie, Marketing und Software. \citep{alliance_members} Der Grund für die Entwicklung von Android war und ist es, einen offenen Standard für mobile Geräte zu schaffen. \citep{alliance_overview}

Dadurch gewährt Android den Entwicklern große Freiheit bei der Programmierung von Systemeigenschaften und Applikationen. Schnittstellen zu anderen Anwendungen und den Services von Google, wie zum Beispiel Google Maps, können somit problemlos genutzt und mit der eigenen App verknüpft werden.

Auch der Hardwarebereich bietet ein breites Spektrum an Geräten, deren Angebot von kostengünstig bis hochpreisig reicht und jede Qualitätsstufe bei der technischen Ausstattung abdeckt. Benutzer haben die Möglichkeit, die Benutzeroberfläche und Systemeigenschaften ihrer Geräte weitestgehend frei zu gestalten und zu personalisieren. Für die Beschaffung und Installation von neuen Applikationen sind sie auch nicht an einen offiziellen Store gebunden, sondern können diese aus verschiedensten Quellen beziehen.
\\
\pagebreak

Vorteile:
\begin{itemize}
	\item Open Source
	\item Unabhängigkeit von Anbietern
	\item Personalisierung
	\item Hardwareangebot
\end{itemize}

Nachteile:
\begin{itemize}
	\item Hohe Verbreitung von Schadsoftware
	\item Aktualität der Version ist abhängig vom Gerätehersteller
\end{itemize}

\subsection{iOS}
iOS ist das mobile Betriebssystem des Unternehmens Apple und ist ein Derivat von Mac OS X, welches wiederum auf Unix basiert. Es wird ausschließlich von Apple entwickelt und ist somit nur auf den eigenen Geräten iPhone, iPad und iPod touch zu finden. Mit der Entwicklung wurde unter externer und interner Geheimhaltung 2005 begonnen und das Resultat der Öffentlichkeit zum ersten Mal Anfang 2007 vorgestellt. Bis zur Version 4.0, wurde iOS mit dem Namen iPhoneOS betitelt \citep{apple_ios}. Das Konzept und Design ist schwerpunktmäßig auf hohe Benutzerfreundlichkeit und Funktionalität ausgelegt. 

Durch die proprietäre Struktur des Systems sind eigene Derivate nicht möglich. Benutzer sind für den Bezug von Applikationen auf den offiziellen App Store angewiesen.
Ebenso bei der Hardwarewahl an die Produktpalette von Apple gebunden, welche jährlich eine neue Generation veröffentlicht. Die Personalisierung der Geräte ist dabei nur bedingt möglich, da Anbieter von Drittsoftware keinen Zugriff auf das System haben. Apple bietet jedoch den Vorteil einer Qualitätssicherung, da Applikationen vor der Veröffentlichung einer recht strengen Prüfung unterzogen werden.
\\
\pagebreak

\textbf{Vorteile:}
\begin{itemize}
	\item Kompatibilität von Software und Hardware
	\item Benutzerfreundlichkeit
	\item Geräteübergreifende Kommunikation
	\item Kontrollen bei Veröffentlichung von Anwendungen
\end{itemize}

\textbf{Nachteile:}
\begin{itemize}
	\item Restriktive Firmenpolitik
	\item Proprietäres System
	\item Hardwareauswahl
	\item Anwendungen nur über den App Store
\end{itemize}

\subsection{Windows Phone}
Microsoft stellt seit dem Jahr 2000 Betriebssysteme für mobile Geräte her \citep{microsoft_mobile}. Seitdem hat sich die Namensgebung von Windows Mobile, über Windows Phone, bis zum aktuellsten Windows 10 Mobile vorgearbeitet. Um im allgemeinen Bezug nicht zwischen den Namen hin und her zu wechseln, wird in dieser Arbeit, wenn mobile Windows Systeme erwähnt werden, der Name Windows Phone (oder WP) benutzt.
Die frühen Versionen von Windows Phone, also Windows Mobile und Windows Phone 7 stammen noch von dem Windows CE Kernel ab, wobei die aktuellen Versionen, Windows Phone 8 und Windows 10 Mobile, Derivate des Windows NT Kernels sind. Mit dem neuesten Ableger, Windows 10 Mobile, verspricht Microsoft eine homogene Kommunikations- und Anwendungsstruktur zwischen allen Geräten die mit diesem System betrieben werden. Dazu zählen nicht nur Smartphones und Tablets, sondern auch Notebooks, Desktop PCs und die Spielkonsole Xbox One \citep{windows10_features}.

Microsoft verfolgt mit Windows Phone eine ähnliche proprietäre Struktur wie der Konkurrent Apple. Eigene Derivate des Systems sind also offiziell nicht möglich. Für neue Anwendungen müssen die Benutzer auf das Angebot des Windows Stores zurückgreifen. Jedoch will Microsoft Entwicklern die Möglichkeit bieten, zukünftige Anwendungen universell verfügbar zu machen, so dass diese auf allen Windows Systemen nutzbar sind. Microsoft arbeitet außerdem an einer Technik, die bestehende Projekte von Android und iOS Anwendungen auf die Windows Plattform überführen kann \citep{wp_with_android_ios}.

Die aktuellen Windows Phone Versionen sind, durch eine Allianz von Windows und Nokia, hauptsächlich auf mobilen Geräten von Nokia zu finden \citep{microsoft_nokia}.
Aber auch andere Hersteller bieten Geräte mit Windows Phone an, bisher jedoch in einem überschaubaren Umfang.
\\

Vorteile:
\begin{itemize}
	\item Kompatibilität von Software und Hardware
	\item Universelle Anwendungen
	\item Benutzerfreundlichkeit
\end{itemize}

Nachteile:
\begin{itemize}
	\item Proprietäres System
	\item Anwendungen nur aus dem Windows Store
	\item Geringeres Angebot an Anwendungen
\end{itemize}


\chapter{Native Softwareentwicklung}

\section{Systemvoraussetzungen}
Entwicklung von Software für ein einzelnes, bestimmtes System wird als nativ (lat.: angeboren, natürlich) bezeichnet. Hier sind Dateiformate, Programmiersprachen, Hardware, Entwicklungsumgebungen und Kompilierung den Anforderungen entsprechend angepasst. Alle individuellen Eigenschaften einer Zielplattform werden unterstützt, ohne dass dabei eine eventuelle Portierbarkeit berücksichtigt wird \citep{native_software}.
Die Entwicklung von Applikationen für eine bestimmte Zielplattform, stellt in der Regel gewisse Mindestvoraussetzungen an das Betriebssystem des Entwicklers.


\subsection{Android}
Android Applikationen sind an kein bestimmtes System gebunden und lassen sich somit unter Windows, OS X und Linux entwickeln. Dies wird unter anderem durch die Eigenschaften der Programmiersprache Java und deren virtueller Maschine ermöglicht.
Windows Systeme sollten mindestens Windows XP oder aktuellere Versionen nutzen. Grundsätzlich werden alle 32-Bit Editionen unterstützt und ab Windows 7 auch 64-Bit.
Mac Systeme werden ab OS X 10.5.8 von den offiziellen Entwicklungswerkzeugen unterstützt.
Entwicklungen auf einem Linux System können beispielsweise unter Ubuntu ab Version 8.04 erfolgen. Bei 64-Bit Versionen ist es notwendig, dass diese fähig sind, 32-Bit Anwendungen auszuführen \citep{android_sdk_requirements}. Da die Auswahl an Linux-Distributionen sehr umfangreich und komplex ist, wird in dieser Arbeit auf Linux nicht weiter eingegangen.


\subsection{iOS}
Für den reinen Programmiervorgang von iOS Anwendungen ist prinzipiell jedes System geeignet. Jedoch ist es offiziell nur auf einem Apple OS X System möglich, die geschriebene Software zu kompilieren und auf ein iOS Gerät aufzuspielen. Für Entwickler, die kein OS X System ihr Eigen nennen oder keinen Zugang zu einem solchen haben, besteht die Möglichkeit, einen Cloudservice zu nutzen. MacinCloud bietet eine cloudbasierte Vermietung von OS X Systemen, inklusive der benötigten Entwicklungssoftware \citep{macincloud}. 


\subsection{Windows Phone}
Ähnlich wie bei iOS wird für die Kompilierung von Windows Phone Applikationen ein Windows Betriebssystem vorausgesetzt. Für die Entwicklung einer Windows Phone 8 App wird mindestens ein Windows 8 Betriebssystem benötigt. Das SDK 8.0 wird aber nur von der 64-bit Version unterstützt. Weiter wird beispielsweise für die Nutzung des Simulators eine Windows 8 Pro Version und die Virtualisierungstechnologie Hyper-V benötigt. Das Windows 10 SDK erwartet minimal Windows 7. Der Simulator benötigt die gleichen Mindestanforderungen wie bei Windows 8 \citep{WP8_requirements, WP10_SDK, WP10_Emulator}. 


\section{SDKs und Versionen}
Software Development Kits, kurz SDKs, liefern dem Entwickler die Softwarebibliotheken, Anwendungen und bestenfalls eine aktuelle Dokumentation, um für eine bestimmte Zielplattform entwickeln zu können. Auch sind sie notwendig, um den geschriebenen Code je nach Art zu interpretieren oder zu kompilieren. Um die aktuellste Version eines mobilen Systems zu unterstützen, muss das SDK auf ebenso aktuellem Stand sein.

\pagebreak

\subsection{Android Versionen}
Android Versionen sind nach süßen Leckereien benannt und den Anfangsbuchstaben nach alphabetisch aufsteigend, wie in Tabelle \ref{tab_android_vers} zu sehen ist.
Das aktuelle SDK kann direkt in Verbindung mit der Entwicklungsumgebung Android Studio oder auch einzeln bezogen werden.

\begin{table}[htbp]
	\centering
	\resizebox{1\textwidth}{!}{%
		\begin{tabular}{|c|c|c|c|}
			\hline
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Codename}} & {\color[HTML]{FFFFFF} \textbf{Version}} & {\color[HTML]{FFFFFF} \textbf{API Level}} & {\color[HTML]{FFFFFF} \textbf{Erscheinungsdatum}} \\ \hline
			Marshmallow                              & 6                                       & 23                                        & 5. Oktober 2015                                   \\ \hline
			Lollipop                                 & 5.1                                   & 22                                        & 9. März 2015                                      \\ \hline
			Lollipop                                 & 5.0.x                                   & 21                                        & 3. November 2014 - 19. Dezember 2014              \\ \hline
			Wear                                     & 4.4W                                    & 20                                        & Juni 2014                                         \\ \hline
			KitKat                                   & 4.4.x                                   & 19                                        & 31. Oktober 2013 - 19. Juni 2014                  \\ \hline
			Jelly Bean                               & 4.3.x                                   & 18                                        & 24. Juli 2013 - 4. Oktober 2013                   \\ \hline
			Jelly Bean                               & 4.2.x                                   & 17                                        & 13. November 2012 - 12. Februar 2013              \\ \hline
			Jelly Bean                               & 4.1.x                                   & 16                                        & 27. Juni 2012 - 10. Oktober 2012                  \\ \hline
			Ice Cream Sandwich                       & 4.0.3 - 4.0.4                           & 15, NDK 8                                 & 16. Dezember 2011 - 4. Februar 2012               \\ \hline
			Ice Cream Sandwich                       & 4.0 - 4.0.2                             & 14, NDK 7                                 & 19. Oktober 2011 - 15. Dezember 2011              \\ \hline
			Honeycomb                                & 3.2                                   & 13                                        & 16. Juli 2011                                     \\ \hline
			Honeycomb                                & 3.1                                     & 12, NDK 6                                 & 10. Mai 2011                                      \\ \hline
			Honeycomb                                & 3                                       & 11                                        & 23. Februar 2011                                  \\ \hline
			Gingerbread                              & 2.3.3 - 2.3.7                           & 10                                        & 23. Februar 2011 - 20. September 2011             \\ \hline
			Gingerbread                              & 2.3 - 2.3.2                             & 9, NDK 5                                  & 6. Dezember 2010 - Januar 2011                    \\ \hline
			Froyo                                    & 2.2 - 2.2.2                             & 8, NDK 4                                  & 20. Mai 2010 - Januar 2011                        \\ \hline
			Eclair                                   & 2.1                                     & 7, NDK 3                                  & 12. Dezember 2010                                 \\ \hline
			Eclair                                   & 2.0.1                                   & 6                                         & 3. Dezember 2009                                  \\ \hline
			Eclair                                   & 2                                       & 5                                         & 26. Oktober 2009                                  \\ \hline
			Donut                                    & 1.6                                     & 4, NDK 2                                  & 15. September 2009                                \\ \hline
			Cupcake                                  & 1.5                                     & 3, NDK 1                                  & 30. April 2009                                    \\ \hline
			ohne Codename                            & 1.1                                     & 2                                         & 10. Februar 2009                                  \\ \hline
			ohne Codename                            & 1                                       & 1                                         & 23. September 2008                                \\ \hline
		\end{tabular}
	}
	\caption{Android Versionen und ihr Erscheinungsdatum}\label{tab_android_vers}\citep{android_codenames,android_version_releases}
\end{table}
\clearpage

\subsection{iOS Versionen}
Apple nutzt für seine Produkte Codenamen, die keinem bestimmten Muster folgen. Verbrauchern sind diese meist unbekannt, da die Namen überwiegend intern genutzt werden. In Tabelle \ref{tab_ios_vers} sind die derzeitigen Versionen aufgelistet.
Das SDK wird offiziell ausschließlich in Verbindung mit XCode bezogen.
 
\begin{table}[htbp]
	\centering
	\resizebox{0.6\textwidth}{!}{%
		\begin{tabular}{|c|c|c|}
			\hline
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Codename}} & {\color[HTML]{FFFFFF} \textbf{Version}} & {\color[HTML]{FFFFFF} \textbf{Erscheinungsdatum}} \\ \hline
			Monarch                                  & 9.2 Beta                                & 3. November 2015                                  \\ \hline
			Monarch                                  & 9.1                                     & 21. Oktober 2015                                  \\ \hline
			Monarch                                  & 9.0.x                                   & 16. September 2015                                \\ \hline
			Copper                                   & 8.4.x                                   & 30. Juni 2015                                     \\ \hline
			Stowe                                    & 8.3                                     & 8. April 2015                                     \\ \hline
			OkemoZurs                                & 8.2                                     & 9. März 2015                                      \\ \hline
			OkemoTaos                                & 8.1.x                                   & 9. Dezember 2015                                  \\ \hline
			Okemo                                    & 8.0.x                                   & 17. September 2014                                \\ \hline
			Sochi                                    & 7.1.x                                   & 10. März 2014                                     \\ \hline
			Innsbruck                                & 7.0.x                                   & 18. September 2013                                \\ \hline
			Brighton                                 & 6.1.x                                   & 21. Februar 2013                                  \\ \hline
			Sundance                                 & 6.0.x                                   & 19. September 2012                                \\ \hline
			Hoodoo                                   & 5.1.x                                   & 7. März 2012                                      \\ \hline
			Telluride                                & 5.0.x                                   & 12. Oktober 2011                                  \\ \hline
			Durango                                  & 4.3.x                                   & 9. März 2011                                      \\ \hline
			Jasper                                   & 4.2.x                                   & 22. November 2010                                 \\ \hline
			Baker                                    & 4.1                                     & 8. September 2010                                 \\ \hline
			Apex                                     & 4.0.x                                   & 21. Juni 2010                                     \\ \hline
			Wildcat                                  & 3.2.x                                   & 3. April 2010                                     \\ \hline
			Northstar                                & 3.1.x                                   & 9. September 2009                                 \\ \hline
			Kirkwood                                 & 3.0.x                                   & 17. Juni 2009                                     \\ \hline
			Timberline                               & 2.2.x                                   & 21. November 2008                                 \\ \hline
			Sugarbowl                                & 2.1.x                                   & 9. September 2008                                 \\ \hline
			Big Bear                                 & 2.x                                     & 11. Juli 2008                                     \\ \hline
			Little Bear                              & 1.1.x                                   & 14. September 2007                                \\ \hline
			Alpine                                   & 1.0.x                                   & 29. Juni 2007                                     \\ \hline
		\end{tabular}
	}
\caption{iOS Versionen und ihr Erscheinungsdatum}\label{tab_ios_vers}\citep{ios_codenames}
\end{table}

\subsection{Windows Phone Versionen}
Tabelle \ref{tab_WP_versions} berücksichtigt alle Versionen ab Windows Phone 7. Die Unterstützung seitens Microsoft wurde bereits eingestellt. Version 8 soll laut Angabe bis etwa 2017 weitergeführt werden, bis die Portierungen der Nutzer zu Windows 10 abgeschlossen sind.

\begin{table}[htbp]
	\centering
	\resizebox{0.7\textwidth}{!}{%
		\begin{tabular}{|c|c|c|}
			\hline
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Codename}} & {\color[HTML]{FFFFFF} \textbf{Version}} & {\color[HTML]{FFFFFF} \textbf{Erscheinungsdatum}} \\ \hline
			Windows Phone 7                          & 7.0.7004.0                              & 21. Oktober 2010                                  \\ \hline
			PreNoDo                                  & 7.0.7008.0                              & 21. Februar 2011                                  \\ \hline
			NoDo                                     & 7.0.7390.0                              & 22. März 2011                                     \\ \hline
			& 7.0.7392.0                              & 3. Mai 2011                                       \\ \hline
			& 7.0.7403.0                              & September 2011                                    \\ \hline
			7.5 / Mango                              & 7.10.7720.68                            & 27. September 2011                                \\ \hline
			& 7.10.7740.16                            & 17. November 2011                                 \\ \hline
			& 7.10.8107.79                            & 4. Januar 2012                                    \\ \hline
			& 7.10.8112.7                             & Juni 2012                                         \\ \hline
			7.5 Refresh / Tango                      & 7.10.8773.98                            & 27. Juni 2012                                     \\ \hline
			& 7.10.8779.8                             & 15. August 2012                                   \\ \hline
			& 7.10.8783.12                            & 30. Januar 2013                                   \\ \hline
			7.8                                      & 7.10.8858.136                           & 30. Januar 2013                                   \\ \hline
			& 7.10.8860.142                           & 14. März 2013                                     \\ \hline
			& 7.10.8862.144                           & 15. März 2013                                     \\ \hline
			8.0 / Apollo                             & 8.0.9903.10                             & 29.Oktober 2012                                   \\ \hline
			Portico                                  & 8.0.10211.204                           & 29. Januar 2013                                   \\ \hline
			Apollo+                                  & 8.0.10327.77                            & 19. Juli 2013                                     \\ \hline
			& 8.0.10512.142                           & 14. Oktober 2013                                  \\ \hline
			Blue                                     & 8.10.12397.895                          & 16. Juli 2014                                     \\ \hline
			& 8.10.14234.375                          & 5. Dezember 2014                                  \\ \hline
			& 8.10.15148.160                          & 11. April 2015                                    \\ \hline
			Windows 10                               & 10.0.10586.0                            & 20. November 2015                                 \\ \hline
			& 10.0.10586.29                           & 8. Dezember 2015                                  \\ \hline
		\end{tabular}
	}
	\caption{Windows Phone Versionen und ihr Erscheinungsdatum}
	\label{tab_WP_versions}\citep{WP7_version_releases, WP8_version_releases, WP10_version_releases}
\end{table}

\pagebreak

\section{Programmiersprachen}
In der nativen Entwicklung werden für jede Zielplattform bestimmte Programmiersprachen unterstützt. 

\subsection{Android}
Android Applikationen werden grundsätzlich in Java entwickelt. Demnach ist es notwendig, zusätzlich eine aktuelle Java Version (JDK) zu installieren. Diese wird von dem Unternehmen Oracle in der aktuellen Version 8  vertrieben \citep{java_jdk}. In Kapitel \ref{subsec:libGDX} wird noch etwas detaillierter auf Java eingegangen. 


\subsection{iOS}
Die primäre Programmiersprache für iOS und OS X ist derzeit die objektorientierte Sprache Objective-C, die eine Erweiterung von C ist und Einflüsse von Smalltalk aufweist. Von Smalltalk werden beispielsweise die Syntax deren Objekteigenschaften abgeleitet. Trotzdem besteht bei nicht-objektorientierten Operationen weiterhin die Nähe zur C Syntax. Objective-C befindet sich aktuell in der Version 2.0 \citep{objectiveC_about}.

Alternativ kann die relativ junge Sprache Swift verwendet werden. Diese ist ebenfalls objektorientiert und in der aktuellen Version 2.0. Im Dezember 2015 wurde der Quellcode Open Source zur Verfügung gestellt. Swift soll Objective-C allerdings nicht ersetzen, sondern eine zusätzliche Möglichkeit darstellen \citep{swift_about}. Die beiden Sprachen sind miteinander kompatibel, so dass es möglich ist, beide innerhalb eines Projekts zu nutzen.

\subsection{Windows Phone}
Für die Programmierung der Logik hat ein Entwickler die Freiheit C\#, Visual Basic, JavaScript oder C++ zu nutzen. Um die Benutzeroberflächen zu gestalten, wird hauptsächlich die Sprache XAML (Extensible Application Markup Language) eingesetzt. 


\section{Entwicklungsumgebungen}
Für die Entwicklung werden seitens der Betreiber jeweils verschiedene IDEs (Integrated Development Environment)  unterstützt und empfohlen. Eine Besonderheit bei IDEs für mobile Systeme ist die Unterstützung eines Simulators. Dieser virtualisiert ein spezifiziertes Gerät, um die Anwendung direkt testen zu können.

\subsection{Android}
Android empfiehlt die eigene, offizielle IDE Android Studio. Diese ist kostenfrei erhältlich und basiert auf der IDE IntelliJ IDEA von JetBrains \citep{android_studio}. Als Alternative gilt der Open Source Vorgänger Eclipse.

\subsection{iOS}
Xcode ist die IDE von Apple, ohne die eine Kompilierung von iOS Projekten nicht möglich ist.
Sie befindet sich derzeit in der stabilen Version 7 und liefert das benötigte SDK sowie einen umfangreichen Simulator der alle mobilen Apple Geräte virtualisieren kann. Xcode ist ebenfalls verpflichtend, wenn die kompilierte Anwendung auf ein Mobilgerät installiert und getestet werden soll. Seit dem 3. Quartal 2015 ist dafür keine kostenpflichtige Entwicklerlizenz mehr nötig, denn diese wird nur noch bei einer Veröffentlichung im App Store verlangt \citep{t3n_xcode7}.
Eine Alternative bietet JetBrains IDE Appcode, welches eine kompatible, aber kostenpflichtige Erweiterung zu Xcode ist \citep{appcode}.

\subsection{Windows Phone}
Microsoft setzt für die Kompilierung und Realisierung für Windows Phone Projekte eine Visual Studio IDE voraus, welche für unkommerzielle Entwicklungen kostenfrei ist \citep{visual_studio}.

\pagebreak

\section{Native Spieleentwicklung}
Bei der nativen Entwicklung basieren die mobilen Applikationen auf den jeweiligen SDKs. Auch mobile Spiele können auf nativem Weg realisiert werden. Die Verwendung der mitgelieferten Grafikfunktionen für die Visualisierung und selbst definierte Spielweltlogik, kann schon eine Basis für einfache 2D Spiele verkörpern. Durch die freie Grafikbibliothek OpenGL können Spielinhalte in 2D oder sogar 3D dargestellt werden. Allerdings ist OpenGL nicht für Windows Phone verfügbar, denn hier wird das eigene Pendant, DirectX, verwendet. Um die Spieleentwicklung zu erleichtern, können spezialisierte Frameworks und Engines genutzt werden, die eigens für die native Entwicklung von Spielen konzipiert wurden und auf die gewünschte Plattform abgestimmt sind. In den folgenden Unterkapiteln werden beispielhafte Werkzeuge für die jeweiligen Plattformen aufgelistet.
 

\subsection{Android}
Für Android existieren einige Frameworks, wovon jedoch viele auf einem veralteten Stand sind. Das ist häufig damit verbunden, dass diese aus privatem Interesse entstanden sind und ein unkommerzielles, kostenloses Vertriebsmodell betreiben. Daher sind regelmäßige Aktualisierungen oft nicht gewährleistet und manche Arbeiten wurden auch ganz eingestellt.

\bigskip
\textbf{AndEngine}\\
Eine Game Engine, die auf OpenGL basiert und für 2D Spiele ausgelegt ist.
Die letzte Aktualisierung erfolgte im Dezember 2013 \citep{andEngine}.

\bigskip
\textbf{Cocos2D-Android}\\
Eine Implementierung von Cocos2D für Android. Die Weiterentwicklung wurde allerdings eingestellt und die letzte Änderung erfolgte im Januar 2010 \citep{cocos2d_android}.

\bigskip
\textbf{jPCT-AE}\\
Eine 3D Engine, die auf jPCT für Desktopanwendungen mit Java basiert und für Android portiert wurde. Die Grafik wird von OpenGL 1.x und 2.0 unterstützt. Das Projekt wird aktuell weiterentwickelt und ist frei verfügbar \citep{jpct_ae}.


\subsection{iOS}
Auch für iOS sind diverse Frameworks erhältlich. Die Suche nach einer aktuellen Entwicklungsunterstützung gestaltet sich hier ein wenig einfacher, wobei man aber, genau wie bei Android, auch auf aufgegebene Projekte stößt. Ein großer Vorteil besteht aber durch SpriteKit, da dies von Apple selbst entwickelt wurde und eine gewisse Sicherheit bei zukünftiger Unterstützung gewährleistet.

\bigskip
\textbf{SpriteKit}\\
Eine Eigenentwicklung von Apple für 2D Spiele auf iOS und OS X. Es kann Objective-C oder Swift genutzt werden \citep{about_spritekit}.

\bigskip
\textbf{Cocos2D-iPhone}\\
Ein Abkömmling von Cocos2D für iOS mit den Implementierungen für Objective-C und zukünftig auch Swift. Dies ist einer der offiziellen Hauptzweige von Cocos2D, der stetig aktualisiert wird \citep{cocos2d_iphone}.

\bigskip
\textbf{Sparrow}\\
Eine aktuelle Open Source Game Engine für iOS Spiele, die ausschließlich Objective-C unterstützt \citep{sparrow}.


\subsection{Windows Phone}
Frameworks, die einzig und allein für Windows Phone Spiele ausgelegt sind, waren nicht direkt ausfindig zu machen. Microsoft selbst rät zu dem eigenen XNA Framework, womit auch die meisten Entertainment Plattformen von Microsoft bedient werden können \citep{xna}. Hauptsächlich werden hier Cross Plattform Tools genutzt, da die Verbreitung von entsprechender Hardware noch relativ gering ausfällt. Auch durch das neue Windows 10 und den Wunsch nach universellen Anwendungslösungen, besteht derzeit ein noch nicht abgeschlossener Änderungsprozess. Dadurch werden spezialisierte Lösungen für eine Windows Gerätekategorie zukünftig vermutlich eher uninteressant.

\pagebreak

\section{Zusammengefasste Übersicht}
Die Tabelle \ref{platform_differnces} soll eine kompaktere Übersicht der einzelnen Systeme bieten.

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{cccc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Eigenschaft}}         & {\color[HTML]{FFFFFF} \textbf{Android}} & {\color[HTML]{FFFFFF} \textbf{iOS}} & {\color[HTML]{FFFFFF} \textbf{Windows Phone}}     \\
			\cellcolor[HTML]{FFFFFF}\textbf{Virtuelle Maschine} & Dalvik VM                      & -                          & CLR                                      \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Programmiersprache}                         & Java                           & Objective-C, Swift         & C\#, C++, Visual Basic, JavaScript, .NET \\
			\cellcolor[HTML]{FFFFFF}\textbf{User Interface}     & XML                            & Cocoa Touch                & XAML                                     \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Speicher Management}                          & Garbage collector              & Reference counting         & Garbage collector                        \\
			\cellcolor[HTML]{FFFFFF}\textbf{IDE}                & Eclipse, Android Studio        & Xcode                      & Visual Studio                            \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Entwicklungsplattform}                      & Multi-Plattform                & Mac OS X                   & Windows                                  \\
			\cellcolor[HTML]{FFFFFF}\textbf{Geräte}             & Heterogen                      & Homogen                    & Homogen                                  \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{App Markt}                                  & Google Play Store              & Apple App Store            & Windows Phone Store                     
		\end{tabular}
	}
	\caption{Unterschiede zwischen Android, iOS und Windows Phone}
	\label{platform_differnces}
\end{table}


\chapter{Plattformübergreifende Entwicklung}
Die Entwicklung von Softwareprodukten und Services, welche auf mehreren Systemen oder Laufzeitumgebungen funktioniert, wird als plattformübergreifende oder auch Cross-Plattform Entwicklung definiert. Um dies zu gewährleisten, nutzen Entwickler unterschiedliche Methoden und Techniken, um verschiedene Systeme mit einer Projektstruktur zu erreichen \citep{cross_plattform_explanation}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/nativ_vs_cross}
	\caption{Traditionelle und plattformübergreifende Entwicklungsmodelle}\label{graph_nativ_vs_cross}
\end{figure}


\section{Ziel}
Die Idee und das Ziel von plattformübergreifender Entwicklung sind, dass eine Softwareanwendung auf mehr als einer spezifischen digitalen Umgebung zufriedenstellend funktioniert. Diese Vorgehensweise wird angewandt, um ein Softwareprodukt auf mehreren proprietären Betriebssystemen zu vertreiben. Dies soll die Entwicklungszeit und sich daraus ergebene Kosten einsparen. Durch die Entwicklung von mobilen Geräten sowie die zunehmende Verbreitung von Open Source Technologien entstanden sukzessiv unterschiedliche Ansätze zur Realisierung.

Die Nutzung dieser Arbeitsweisen hat aber nicht nur Vorteile. Als nachteilig gilt die potentiell geringere Effizienz der Anwendung gegenüber der nativen Entwicklung. Beispielsweise enthält das Programm redundante Prozesse oder für jede Plattform einen eigenen Datenspeicherordner. Die Reduzierung von Komplexitäten kann auch bis zur „Verdummung“ des Programms ausarten, um das Programm für weniger anspruchsvolle Softwareumgebungen anzugleichen. 

Trotz mancher momentanen Grenzen bietet die plattformübergreifende Entwicklung ausreichende Möglichkeiten, die eine derartige Projektstruktur befürworten \citep{cross_plattform_explanation}.

\section{Funktionsweise und Realisierungsansätze}
Zu den grundlegenden Strategien gehört, dass ein Projekt oder Programm auf einen allgemein verständlichen Zwischencode (z.B. Bytecode) reduziert wird, um daraufhin zu verschiedenen Zielbetriebssystemen kompiliert zu werden. Weitere Methoden beinhalten die Verwendung von Teilbäumen in der Projektstruktur, um die Anwendung bestmöglich an die Eigenheiten der entsprechenden Zielplattform anzupassen. Ein anderer Ansatz ist die Abstraktion des Codes auf unterschiedlichen Ebenen, um sich mehreren Softwareumgebungen anzunähern. Softwareprojekte, die solche Verfahren anwenden, kann man als plattformunabhängig, genauer gesagt plattformübergreifend, bezeichnen, da sie die unterstützten Systeme gleich werten und keines bevorzugen \citep{cross_plattform_explanation}.

\bigskip
Die Entwicklung von plattformübergreifenden Anwendungen auf mobilen Systemen wird in sechs verschiedene Ansätze kategorisiert. Diese Ansätze werden zum Teil in Unteransätze aufgeteilt, wie in Abbildung \ref{graph_cross_plattform_approaches} zu sehen ist.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Bilder/Cross_Plattform_Ansaetze}
	\caption{Haupt- und Unteransätze zur Entwicklung von mobilen, plattformübergreifenden Anwendungen}\label{graph_cross_plattform_approaches}
\end{figure}

In den folgenden Unterkapiteln werden die einzelnen Ansätze und Unteransätze näher betrachtet. Die Analyse und Betrachtung der folgenden Abschnitte basieren auf den Informationen der Ausaurbeitung von \textit{„Taxonomy of Cross-Platform Mobile Applications Development Approaches“} \citep{cross_plattform_approaches}.

\subsection{Kompilierung}
Der Kompilierungsansatz wird in zwei Unterkategorien aufgeteilt:

\begin{itemize}
	\item Cross-Compiler
	\item Trans-Compiler
\end{itemize}

Der Compiler ist ein Programm, welches den Quellcode einer High-Level Programmiersprache in einen Low-Level Code übersetzt. Dieser Low-Level Code ist ein Binärcode in Maschinensprache, der von Prozessoren verstanden wird. Dieser Konvertierungsprozess wird als Kompilierung bezeichnet.

\bigskip
Man spricht von einem \textbf{Cross-Compiler}, wenn das System auf dem der Compiler sich befindet unterschiedlich zu dem System ist, auf dem der kompilierte Code ausgeführt werden soll. Die Zielsysteme können Betriebssysteme, Prozessoren oder eine Kombination aus beiden sein. Abbildung \ref{graph_compilation_XMLVM} stellt eine von XMLVM gebotene Lösung eines Cross-Compilers dar. Dieser Compiler nutzt XML für die Darstellung des Frontends und eine virtuelle Maschine (VM) für die Verarbeitung des Bytecodes.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{Bilder/Compilation_Cross_XMLVM}
	\caption{XMLVM Prozess mit Java oder .NET Quellcode}\label{graph_compilation_XMLVM}\citep{XMLVM_Toolchain}
\end{figure}

\bigskip
Ein \textbf{Trans-Compiler} kompiliert eine High-Level Programmiersprache in eine andere High-Level Programmiersprache. Da viele Sprachen jedoch unterschiedliche Eigenschaften und Leistungsmerkmale besitzen, muss der generierte Code unter Umständen nachbearbeitet werden, wenn der Compiler die Quelleigenschaften nicht für die Zielsprache übersetzen kann. Zudem ist der Code durch die automatisierte Erzeugung in der Regel nur schwer von Menschen lesbar. Es besteht außerdem eine Abhängigkeit zu regelmäßigen Updates, um die Änderungen der Quell- und Zielsysteme aktuell zu halten und aufeinander abzustimmen.

\subsection{Komponentenbasiert}
Die Komponente besteht aus einem Paket oder einem Modul, dessen Funktionen und Daten untereinander in Relation stehen. Jede Komponente besitzt eine Schnittstelle, welche die Servicedienste spezifiziert, die von anderen Komponenten genutzt werden können. Die Kommunikation findet ausschließlich über die Schnittstellen statt, so dass eine Komponente keinerlei Informationen über den internen Aufbau einer anderen benötigt. 

\bigskip
Ein theoretischer, komponentenbasierter Lösungsansatz der nicht offiziell betitelt ist, versucht die Entwicklung mobiler Web-Apps dahingehend zu vereinfachen, dass durch das Konzept von Softwarekomponenten, die Kernfunktionalitäten modular aufgeteilt werden. Diese Module beinhalten Speichermanagement, Netzwerkkommunikation, Grafik, Dateisystem und die Systemdienstkomponenten. Dadurch erhalten die Komponenten eine Wiederverwertbarkeit und vereinfachen die Migration auf andere Plattformen. Jede Plattform kann dieselben Schnittstellen nutzen, benötigt jedoch eine eigene innere Implementierung für die Unterstützung. 

\subsection{Interpretierung}
Bei der Interpretierung übersetzt ein Interpreter (Dolmetscher) den Quellcode, meist in Form von Skriptsprachen, in ausführbare Anweisungen. Dies geschieht in Echtzeit mit Hilfe einer dedizierten Maschine. Hierbei existieren drei Unteransätze:

\begin{itemize}
	\item Virtuelle Maschine (VM)
	\item Webbasiert (Web-based)
	\item Laufzeit Interpretation (Runtime Interpretation)
\end{itemize}

Die bekannteste \textbf{virtuelle Maschine} ist die Java Virtual Machine (JVM). Diese verfügt über eine eigene, komplette Hardwarearchitektur mit CPU, Stack, Register und einem korrespondierenden Befehlssystem. Die Grundidee hierbei ist es, die mobile App mit einer plattformübergreifenden Sprache zu entwickeln, die auf der dedizierten, virtuellen Maschine läuft und auf entsprechenden Plattformen installiert ist. In Abbildung \ref{graph_interpreter_Dalvik} wird der Interpretierungsablauf der von Android bekannten Dalvik VM dargestellt.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{Bilder/Interpretation_VM_Dalvik}
	\caption{Ablauf des Dalvik VM Interpreter}\label{graph_interpreter_Dalvik}
\end{figure}

\bigskip
\textbf{Webbasierte} Tools verwenden Technologien wie HTML(5), Javascript und CSS, die auf verschiedenen Plattformen ausführbar sind. Der Zugriff auf Hardwarekomponenten wie Kamera und Sensoren erfolgt durch Wrapper. Wrapper sind Adapter oder Schnittstellen, um auf die nativen APIs zugreifen zu können. Abbildung \ref{graph_interpreter_PhoneGap} zeigt die Kommunikation und Interpretierung des webbasierten Interpreters PhoneGap von Adobe.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{Bilder/Interpretation_Web_PhoneGap}
	\caption{Vereinfachter Ablauf des PhoneGap Interpreters von Adobe}\label{graph_interpreter_PhoneGap}
\end{figure} 

\pagebreak

\bigskip
Die \textbf{Laufzeit} ist eine Schicht und Ausführungsphase, welche die mobile App auf der nativen Plattform lauffähig macht. Bei diesem Ansatz wird der Quellcode in Bytecode umgewandelt und dann zur Laufzeit ebenfalls von einer virtuellen Maschine ausgeführt. In Abbildung \ref{graph_interpreter_Titanium} wird die Verarbeitung von Appcelerators Titanium-Interpreters dargestellt.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{Bilder/Interpretation_Runtime_Titanium}
	\caption{Ablauf des Titanium Interpreters von Appcelerator}\label{graph_interpreter_Titanium}
\end{figure}

\subsection{Modellierung}
Bei der Modellierung verwenden Entwickler abstrakte Modelle, um die Funktionen und/oder die Benutzeroberfläche der Anwendungen zu beschreiben. Diese Modelle werden für jede Zielplattform in entsprechenden Quellcode transformiert. Hierbei gibt es die Ansätze des Model-Based User Interface Development (MB-UID) und des Model-Driven Development (MDD).

\bigskip
\textbf{MB-UID} wird genutzt, um die Benutzeroberfläche durch die formale Beschreibung von Aufgaben, Daten und Benutzern einer App automatisch zu generieren. Hierbei wird zwischen der Benutzeroberfläche und der Logik unterschieden.
Für die Generierung existieren zwei Strategien:

\begin{itemize}
	\item Die Generierung zur Laufzeit der App, die Websysteme adaptiert und auf Anfrage- und Antwortprotokollen (request/response) basiert. Eingeschränkt wird dies durch die Voraussetzung einer dauerhaften Verbindung zu einem Server.
	
	\item Die Generierung während der Entwicklungszeit, also vor Ausführung der Anwendung. Hier kann der Entwickler das generierte Interface überprüfen und zu jeder Plattform spezifische Funktionalitäten hinzufügen. Dabei kann die Funktion zur Verbindungsart festgelegt werden, ob eine dauerhafte Verbindung bestehen soll oder zu einem selbst bestimmten Zeitpunkt synchronisiert wird.
\end{itemize}

\bigskip
Das Hauptkonzept von \textbf{MDD} ist die Generierung von plattformspezifischen Versionen, basierend auf dem plattformunabhängigen, abstrakten Modell. Das Modell wird zum Beispiel durch Domain-Specific Language (DSL) beschrieben.

\subsection{Cloudbasiert}
In diesem Ansatz wird die Logik der Anwendung nicht lokal auf dem Gerät verarbeitet, sondern auf einem Cloudserver. Dabei werden einige Cloudeigenschaften genutzt, wie Flexibilität, Virtualisierung, Sicherheit und dynamisches Management. Die Clientanwendung ist dabei weitestmöglich reduziert, da diese nur Basisprozesse zur Kommunikation benötigt. Dies wird Thin-Client genannt, da, wie in Abbildung \ref{client_aufgaben}, nur Ein- und Ausgabe verarbeitet werden müssen. Cloudbasierte Anwendungen sollen dadurch besonders energieeffizient sein.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Aufgaben_Endgeraet}
	\caption{Aufgaben von Client-Anwendungen}\label{client_aufgaben}
\end{figure}

Da zur Zeit der Bearbeitung zu diesem Ansatz keine praktischen Umsetzungen gefunden wurden, sondern nur der theoretische Aufbau einer solchen Applikation, wird dieser Teil mangels Beispielen nicht weiter vertieft.

\subsection{Vereinigung}
Dieser Ansatz versucht die besten Eigenschaften verschiedener Ansätze zusammenzuführen (Merge), von den jeweiligen Vorteilen zu profitieren und Nachteile zu minimieren.

\bigskip
Ein unbetitelter Lösungsansatz vereinigt den komponentenbasierten Ansatz mit dem Cross-Compiler und einer darauf angepassten Universalsprache. Um die nativen Hardwarefunktionen wie Kamera und GPS sowie native Softwareeigenschaften wie Buttons und andere Interaktionsfelder anzusprechen, wird eine Sammlung an spezialisierten Komponenten erstellt. Implementierungen dieser Komponenten können durch gemeinsame Schnittstellen für jede Zielplattform erfolgen. Dieses Framework soll dem Entwickler ermöglichen Applikationen zu entwickeln, die auf nativen Code und der definierten Universalsprache basieren. Diese Sprache wird der App als zusätzliche Kommunikationsschicht und Schnittstelle hinzugefügt, um die Komponenten und deren Methoden anzusprechen (vgl. Abb. \ref{graph_merge_component_based}). Der Entwickler implementiert nur eine minimale Grundstruktur der App auf nativer Basis, welche die Benutzerschnittstelle und Navigation beinhaltet. An welcher Stelle und auf welche Weise die Komponenten integriert werden, wird durch die Universalsprache definiert. Das Framework regelt die Codeintegrierung innerhalb des nativen Codes. Bei diesem Lösungsansatz ist es erforderlich, die Benutzerschnittstelle für jede Plattform manuell zu definieren. Dabei liegt der funktionale Fokus auf allgemeingültigen Methoden.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.9\textwidth]{Bilder/Merge_Component_based}
	\caption{Funktion eines komponentenbasierten Mergeansatz}\label{graph_merge_component_based}
\end{figure}

\bigskip
\textbf{Integrated Cross-Platform Mobile Development (ICPMD)} ist eine weitere Lösung, die auf dem Vereinigungsprinzip aufbaut und drei Verwendungsszenarios unterstützt. Diese Szenarios sind, wie in Abbildung \ref{graph_merge_integrated_based} dargestellt, abhängig von dem gegebenen Input.

\pagebreak

\bigskip 
Der Entwickler hat…
 
\begin{enumerate}
	\item …bereits ein bestehendes Projekt (z.B. Windows Phone) und möchte dies auf weitere Plattformen (z.B. iOS und Android) ausweiten.
	
	\item …definierte Anforderungen und möchte daraus, auf bestimmten Zielplattformen, eine mobile App erzeugen.
	
	\item …ein Projekt basierend auf dem abstrakten Modell und möchte dies aktualisieren und speichern oder daraus, auf bestimmten Zielplattformen, eine mobile App erzeugen.
\end{enumerate}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Merge_Integrated_based}
	\caption{Drei Szenarien bei ICPMD}\label{graph_merge_integrated_based}
\end{figure}

\section{Übersicht der Ansätze}
Tabelle \ref{table_all_approaches} fasst die Ansätze zur plattformübergreifenden Entwicklung in Kurzform zusammen und benennt die jeweiligen Vor- und Nachteile, sowie die Projekttitel bekannter Lösungen.

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|c|c|p{5cm}|p{6cm}|p{3,2cm}|}
			\hline
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Ansatz}} & {\color[HTML]{FFFFFF} \textbf{Unteransatz}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Pro}}}                                                                                                                                                                                                                                                 & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Contra}}}                                                                                                                    & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{\begin{tabular}[c]{@{}c@{}}Beispielhafte\\ Lösungsansätze\end{tabular}}}} \\ \hline
			\textbf{Kompilierung}                  & Cross-Compiler                              & Wiederverwertung eines existierenden Quellcodes durch Cross-Kompilierung auf eine andere Plattform. Die resultierende Applikation ist nativ und besitzt somit derartige Vorteile.                                                                                                                                    & Die Zuordnungen zwischen zwei Sprachen sind sehr aufwendig, so dass hauptsächlich die gemeinsamen Eigenschaften berücksichtigt werden.                                                                  & MoSync, Corona, Neomades, XMLVM                                                                            \\ \hline
			\textbf{}                              & Trans-Compiler                              & Kann genutzt werden, um veraltete Applikationen und deren veralteten Code auf eine neuere Version derselben Sprache zu übersetzen. Wiederverwertung eines existierenden Quellcodes durch Trans-Kompilierung auf eine andere Plattform. Die resultierende Applikation ist nativ und besitzt somit derartige Vorteile. & Konzentriert sich ausschließlich auf die gemeinsamen APIs von Quell- und Zielsprache. Benötigt regelmäßige Aktualisierungen, um jeweilige Änderungen zu unterstützen. & JUniversal                                                                                                                                    \\ \hline
			\textbf{Komponentenbasiert}            &                                             & Vereinfacht die Unter-stützung neuer Plattformen durch definierte Schnittstellen bei implementierten Komponenten.                                                                                                                                                                                                                 & Konzentriert sich nur auf die Gemeinsamkeiten der unterstützten Plattformen.                                                                                                                           & Theoretisch                                                                                                                                        \\ \hline
			\textbf{Interpretierung}                & Webbasiert                                  & Leicht zu erlernen und zu benutzen, da es auf bekannten Web-Technologien aufbaut.                                                                                                                                                                                                                                                & Die Benutzerschnittstelle von webbasierten Apps besitzen nicht das gleiche Aussehen und Handhabung wie bei nativen Apps. Geringere Perfomance gegenüber nativen Apps.                                  & PhoneGap, Rhomobile, xFace                                            \\ \hline
			\textbf{}                              & Virtuelle Maschine                          & Geringere Gesamtgröße und schnellerer Download der Apps, da alle benötigten Bibliotheken und Funktionen in der VM gespeichert sind.                                                                                                                                                                                              & Langsame Ausführung der Applikation auf der VM. Die VM muss erst aus einem Store geladen werden, was auf iOS nicht unterstützt wird.                                                                   & MobDSL                                                                                                                                               \\ \hline
			\textbf{}                              & Laufzeit                                    & Der Quellcode muss nur einmal geschrieben werden.                                                                                                                                                                                                                                                                                & Geringe Perfomance beim Laden der App, da der Interpretierungsvorgang bei jeder einzelnen Ausführung stattfindet.                                                                               & Titanium                                       \\ \hline
			\textbf{Modellierung}                  & MD-UID                                      & Spart Entwicklungszeit durch Generierung des UI-Codes. Nützlich für Prototyping, durch schnelle UI-Entwicklung und frühe Evaluierung der Benutzerfreundlichkeit.                                                                                                                                                         & Muss sich bei den einzelnen Plattformen auf verallgemeinerte Benutzerschnittstellen konzentrieren.                                                                                                             &  XMobile                                                                                                                                            \\ \hline
			\textbf{}                              & MDD                                         & Die Modellierungssprache ist effektiv, um Anforderungen zu definieren. Der Fokus liegt auf der Funktionalität und nicht auf der technischen Implementierung.                                                                                                                                                                      & Kann existierenden, nativen Quellcode nicht verarbeiten.                                                                                                                                               & JSAF, MD2, Jelly, AppliDE                                                                             \\ \hline
			\textbf{Cloudbasiert}                 &                                             & Verarbeitungsprozesse werden auf einen Cloudserver ausgelagert.                                                                                                                                                                                                                                                                          & Das Endgerät und die App benötigen eine schnelle, permanente Netzwerkverbindung.                                                                                                                       &  Theoretisch                                                                                                                                         \\ \hline
			\textbf{Vereinigung}                   &                                             & Vorteile aus den Stärken anderer Ansätze. Bietet dem Entwickler vielseitige Möglichkeiten.                                                                                                                                                                                                                                       & Benötigt hohen Entwicklungsaufwand.                                                                                                                                                                    &  ICPMD                                                                                                                                             \\ \hline
		\end{tabular}
	}
	\caption{Übersicht aller Ansätze}
	\label{table_all_approaches}
\end{table}

\section{Plattformübergreifende Entwicklung mobiler Applikationen ohne den Schwerpunkt Spieleentwicklung}
Plattformübergreifende Entwicklung für mobile Plattformen ist nicht nur für die Spieleentwicklung interessant.
In der Bachelorthesis „\textit{Plattformabhängige und –unabhängige Entwicklung mobiler Anwendungen am Beispiel von Geo-Wikipedia-App}“ \citep{cross_plattform_development_vehse} wird ebenfalls die plattformübergreifende Entwicklung analysiert, jedoch liegt hier der Fokus nicht auf mobilen Spieleapplikationen und zugehörigen Entwicklungswerkzeugen. Vehse geht in Kapitel 2.2 auch auf die verschiedenen Herangehensweisen ein und klassifiziert deren Resultate. Weiterhin wird eine Auswahl der bekannteren Cross-Plattform Entwicklungstools (PhoneGap, Xamarin, Appcelerator) analysiert. Im Gegensatz zu der Arbeit von Benjamin Vehse, setzt diese Bachelorthesis den Schwerpunkt auf Frameworks und Engines zur Spieleentwicklung und geht daher nicht weiter auf die in seiner genannten und analysierten Entwicklungswerkzeuge ein.


\chapter{Plattformübergreifende Spieleentwicklung}

\section{Definition von Anforderungen für vergleichbare Entwicklungswerkzeuge}
Das Angebot an Werkzeugen für die plattformübergreifende Spieleentwicklung ist vielfältig und es bestehen Unterschiede in der Funktionalität sowie den Möglichkeiten. Zum Zeitpunkt der Bearbeitung dieser Arbeit wurden bei Wikipedia ca. 140 verschiedene, plattformübergreifende Werkzeuge zur Spieleentwicklung aufgelistet \citep{list_of_game_engines}. Da ein Vergleich von allen Produkten solcher Art den Umfang dieser Arbeit drastisch überschreiten würde, werden zuerst grundlegende Anforderungen definiert, um eine spezifischere Auswahl treffen zu können.
 
\bigskip
Das Framework soll folgende Anforderungen erfüllen:
\begin{itemize}
	\item Mobile Geräte gehören zu den Zielplattformen, wobei mindestens Android und iOS enthalten sein müssen.
	\item Es können 2D als auch 3D Spiele entwickelt werden.
	\item Es steht mindestens eine objektorientierte, statisch typisierte Programmiersprache zur Wahl.
	\item Es handelt sich um ein aktuelles Framework, mit regelmäßigen Updates, Dokumentation und einer aktiven Entwicklergemeinschaft.
	\item Ein kostenfrei und kommerziell nutzbarer Produkttyp steht zur Auswahl.
\end{itemize}


Die definierten Anforderungen sind nicht willkürlich gewählt und folgendermaßen gerechtfertigt:

\bigskip
Wie in der Marktanalyse der mobilen Systeme aus Kapitel \ref{subsec:Marktanteile_mobile_Systeme} ermittelt wurde, sind Android und iOS derzeit die beiden entscheidenden mobilen Plattformen und sind daher für die spätere Beispielapplikation maßgebliche Voraussetzungen. 
Auf einen Vergleich der Applikation auf einem Windows Phone wird aus mehreren Gründen verzichtet. Der Marktanteil laut der Analyse ist verhältnismäßig gering und von daher vernachlässigbar. Weiterhin existieren derzeit mehr Geräte mit Windows Phone 8, das aber in naher Zukunft von Windows 10 abgelöst wird.
Die Aktualität des Spieleframeworks ist wichtig, da die Entwicklungswerkzeuge den derzeitigen, technischen Stand der Zielsysteme unterstützen und sich regelmäßig weiterentwickeln sollen. Dazu gehört eine zur Version passende, aktuelle Dokumentation. Eine aktive und lebendige Community von Nutzern und Entwicklern ist wichtig, um eventuelle Problemstellungen leichter lösen zu können sowie potentielle Bugs ausfindig zu machen und diese gegebenenfalls zu melden. Diese Faktoren sind wichtig, um für die nähere Zukunft eine kalkulierbare Sicherheit der weiteren Existenz der Entwicklungssoftware zu gewährleisten. Die Möglichkeit, eine statisch typisierte Programmiersprache zu nutzen, wird vorausgesetzt, da diese, im Vergleich zu dynamischen Skriptsprachen, bei qualifiziertem Umgang in der Regel bessere Performanceleistungen bieten. Auch eventuelle Fehler werden dadurch schon bei der Kompilierung aufgedeckt und nicht erst zur Laufzeit. Durch diese Anforderung wird partiell vorausgesetzt, dass der plattformübergreifende Ansatz die Kompilierung enthält. Daraus folgt, dass Frameworks ausgeschlossen werden, die ausschließlich mit webbasierten Techniken, wie HTML, CSS und JavaScript, arbeiten. Viele aktuelle Smartphones sind von ihrer technischen Ausstattung befähigt, 3D Spiele zu unterstützen und darzustellen. Die Konzeption der Beispielapplikation soll sich deshalb die Wahl zwischen 2D und 3D vorbehalten können. Ein kostenfreier Bezug und uneingeschränkte Nutzung sichert eine größere Entwicklercommunity und vergrößert die Menge des geteilten Wissens. Weiterhin gibt dies die Möglichkeit, barrierefrei und ohne Zeitdruck mit einem Werkzeug zu arbeiten und das Resultat bei Wunsch zu veröffentlichen.

\bigskip
Trotz der geforderten Übereinstimmungen ist es wünschenswert, dass für den Basisquellcode der Projekte nicht dieselben Programmiersprachen genutzt werden, um den Vergleich abwechslungsreicher und kontrastvoller zu gestalten. Anhand dieser Anforderungen werden passende Werkzeuge ausgewählt.


\section{Gamespezifische Frameworks und Engines}
Aufgrund der zuvor gestellten Anforderungen wurde die Auswahl der Vergleichswerkzeuge bedeutend reduziert. Die Wahl fiel auf die beiden Frameworks libGDX und Cocos2D-X sowie die Engine Unity3D. Diese werden in den folgenden Unterkapiteln kurz vorgestellt und darauf in Kapitel \ref{chapter:Analyse_der_Frameworks} anhand der theoretischen Angaben und Möglichkeiten analysiert.

\subsection{libGDX}
Das auf Java basierende Entwicklungsframework libGDX ist unter Apache 2.0 lizensiert.  libGDX ist Open Source und bringt eine Menge an grundlegenden Bibliotheken für die Erstellung von 2D und 3D Spielen mit. Dabei wird allerdings nicht jede Eventualität abgedeckt, denn für spezielle Fälle sollen dem Projekt bei Bedarf entsprechend spezialisierte Module hinzugefügt werden. Dies kann bei der Erstellung eines neuen Projekts oder nachträglich geschehen. Dieses modulare Konzept soll garantieren, dass nur die Funktionalität integriert ist, die auch wirklich benötigt wird. Dafür arbeitet libGDX verstärkt mit anderen quelloffenen Frameworks und Bibliotheken zusammen. Die zur Verfügung stehende Programmiersprache ist Java, welche die Erstellung von Android Anwendungen problemlos möglich macht. Für die Generierung von iOS Apps wird auf die Fähigkeiten des Kompilierers RoboVM zurückgegriffen \citep{libGDX_main_features}. 


\subsection{Cocos2D-X}
Cocos2D-X ist ein Open Source Framework und unter dem MIT (Massachusetts Institute of Technology) lizensiert. Auch hier bestehen zahlreiche Schnittstellen und Kooperationen mit externen Anbietern spezieller Frameworks, wovon einige bereits fester Bestandteil der Standardbibliothek sind. Entwickler haben für die Codebasis die Wahl zwischen C++, Lua und JavaScript. Cocos2D-X ist der plattformübergreifende Ableger der vielgesichtigen Cocos Reihe. Trotz der Namensgebung können auch 3D Anwendungen erstellt werden. Das optionale Programm Cocos Studio unterstützt bei der Gestaltung von Spielszenen. Damit kann die grafische Ebene mit Texturen, Sprites und Menüobjekten angeordnet und daraufhin für die IDE exportiert werden, um die zugehörige Spiellogik zu implementieren. Projekte können aus der Kommandozeile oder einer eigenen Desktopanwendung namens Cocos heraus erstellt werden. Cocos2D-X findet laut eigenen Angaben auch bei großen Spieleentwicklern wie Konami Anklang und wird häufig in ostasiatischen Ländern wie China, Japan und Südkorea verwendet \citep{cocos2d_main_features}. 


\subsection{Unity3D}
Unity3D ist derzeit die international führende Game-Engine. Das System ist proprietär, besitzt aber eine große Anzahl an Schnittstellen für die Nutzung externer Datenobjekte und zusätzlichen Services. Des Weiteren wird durch diese Engine die größte Anzahl an aktuellen Zielplattformen unterstützt. Unity3D findet Verwendung bei Entwicklern verschiedenster Interessengebiete, wie Hobby- und Indieentwickler sowie bei professionellen Studios. Innerhalb des Editors der Engine können Spieleelemente einer Szene direkt hinzugefügt, transformiert, mit Komponenten erweitert und unmittelbar getestet werden. Die Spiellogik kann durch C\#, UnityScript oder Boo Skripte in einer externen IDE umgesetzt, einem Gameobjekt als Komponente hinzugefügt werden oder als eigenständige Klassen operieren. Werte von globalen Objekten und Variablen sind im Editor durch ein entsprechend erzeugtes Formfeld veränderbar. Zudem ist es möglich, Objekte zur Laufzeit im Editor anzupassen und hinzuzufügen. Mit sogenannten Prefabs hat man die Möglichkeit, Kompositionen von Spielobjekten zur Wieder- und Mehrfachverwendung zu speichern. Der zugehörige Assetstore stellt einen vielfältigen Marktplatz dar, der verschiedenste Spielinhalte oder komplette Projekte anbietet \citep{unity_public_relations}. 


\subsection{Weitere Frameworks}
Weitere Werkzeuge zur Spieleentwicklung, die den Anforderungen entsprechen, aber nicht für den Vergleich weiter analysiert werden, sollen an dieser Stelle kurz erwähnt werden.

\bigskip
\textbf{MonoGame}\\
Eine Open Source Implementierung von Microsofts XNA Framework, die eine Vielzahl an Zielplattformen aus verschiedenen Bereichen unterstützt. Als Programmiersprache wird C\# genutzt \citep{monogame}. 

\bigskip
\textbf{AppGameKit}\\
Eine Lösung zur Spielentwicklung, die zwar offiziell nicht kostenfrei, aber für kleines Geld erhältlich ist. Es können C++ oder eine eigens kreierte Skriptsprache namens BASIC genutzt werden \citep{appgamekit}. 

\bigskip
\textbf{Lumberyard}\\
Dies ist eine kostenlose, Open Source Spiele-Engine von Amazon, die zur Zeit der Bearbeitung als Betaversion veröffentlicht wurde und auf der CryEngine basiert \citep{lumberyard}.


\chapter{Analyse der Frameworks}
\label{chapter:Analyse_der_Frameworks}


\section{Zielplattformen}
Die Anzahl der unterstützten Zielplattformen in den Kategorien Mobil, Destop und Web unterscheidet sich bei den drei Werkzeugen nur geringfügig. In Tabelle \ref{zielplattformen_frameworks} wird gezeigt, dass Cocos2D-x und Unity3D dieselben mobilen Systeme unterstützen. In dem Bereich unterscheidet sich libGDX von den anderen Beiden. Die Möglichkeit, für das Blackberry OS Spiele zu entwickeln, ist in diesem Vergleich einzig mit libGDX möglich. Dafür muss bei der Nutzung von libGDX auf Windows Phone verzichtet werden, was aber zukünftig durch Windows 10 Universal Applikationen wieder abgedeckt wird. Alle drei Werkzeuge bieten aber die vorausgesetzte Möglichkeit, gleichzeitig die Systeme von iOS und Android zu bedienen \citep{unity_public_relations,cocos2d_main_features,libGDX_main_features}. 

\begin{table}[htbp]
	\centering
	\resizebox{0.8\textwidth}{!}{%
		\begin{tabular}{cccc}
			\rowcolor[HTML]{000000} 
			\cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} \textbf{}} & {\color[HTML]{FFFFFF} \textbf{Cocos2D-X}} & {\color[HTML]{FFFFFF} \textbf{LibGDX}} & {\color[HTML]{FFFFFF} \textbf{Unity3D}} \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} Mobil}           &                                         &                                        &                                         \\
			\cellcolor[HTML]{C0C0C0}iOS                                             & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Android                                         & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Windows Phone 8                                 & {\color[HTML]{000000} X}                & {\color[HTML]{000000} }                & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Tizen                                           & {\color[HTML]{000000} X}                & {\color[HTML]{000000} }                & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Blackberry                                      & {\color[HTML]{000000} }                 & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                 \\
			& {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} }                 \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} Desktop}         & {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} }                 \\
			\cellcolor[HTML]{C0C0C0}Mac                                             & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Windows                                         & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Universal Windows Platform                      & {\color[HTML]{000000} X}                & {\color[HTML]{000000} }                & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Linux / Steam OS                                & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			& {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} }                 \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} Web}             & {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} }                 \\
			\cellcolor[HTML]{C0C0C0}Web GL                                          & {\color[HTML]{000000} X}                & {\color[HTML]{000000} X}               & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Web Player                                      & {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} X}                \\
			\cellcolor[HTML]{C0C0C0}Java Applet                                     & {\color[HTML]{000000} }                 & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                 \\
			& {\color[HTML]{000000} }                 & {\color[HTML]{000000} }                & {\color[HTML]{000000} }                 \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Gesamt}}             & {\cellcolor[HTML]{BEBEBE} 9}                 & {\cellcolor[HTML]{BEBEBE} 8}                & {\cellcolor[HTML]{BEBEBE} 10}                 \\
		\end{tabular}
	}
	\caption{Unterstützte Zielplattformen der Spieleframeworks}
	\label{zielplattformen_frameworks}\citep{unity_public_relations,cocos2d_main_features,libGDX_main_features}
\end{table}

\section{Programmiersprachen}
Bei der Wahl der Programmiersprachen unterscheiden sich die gewählten Spieleframeworks komplett voneinander. Entwicklern mit unterschiedlichen Kenntnissen, kann durch die Wahl einer vertrauten Sprache somit grundsätzlich ein leichterer Einstieg in die Spieleentwicklung geboten werden. Auch wenn der Anforderung nach hauptsächlich die objektorientierten, statisch typisierten Sprachen für diese Arbeit entscheidend sind, werden zugunsten der Vollständigkeit alle verfügbaren Sprachen erwähnt.

\subsection{libGDX}
\label{subsec:libGDX}
libGDX nutzt einzig und allein Java für die Entwicklung, was für reine Android Spiele ein großer Vorteil ist, denn dadurch müssen bei der Kompilierung kaum Kompromisse eingegangen werden.
Java ist eine weitverbreitete, objektorientierte Programmiersprache, die erstmalig 1995 von dem Unternehmen Sun Microsystem vorgestellt wurde. 2010 übernahm das Unternehmen Oracle Sun Microsystem und damit auch die Weiterentwicklung von Java. Es entstanden verschiedene, spezialisierte Technologielösungen. Die bekanntesten und meistgenutzten stellen dabei Java SE (Standard Edition) und Java EE (Enterprise Edition) dar. Java SE beinhaltet die komplette Standardbibliothek, wobei Java EE um Bibliotheken für die Entwicklung von Server--, Netzwerk-- und Webanwendungen erweitert wurde \citep{java_kompakt}. Das derzeit aktuelle JDK 8 soll 2016 auf Version 9 aufsteigen \citep{java_9}. 
Die Sprache gilt als plattformübergreifend, da Programme in einer virtuellen Maschine, der JVM (Java Virtual Machine), ausgeführt werden. Diese virtuelle Maschine führt den bei der Kompilierung erstellten Bytecode aus und prüft das Programm vorweg auf Laufzeitfehler. 
Die Syntax wurde von C++ und C beeinflusst und besitzt eine statische Typisierung \citep{java_kompakt}. 

\subsection{Cocos2D-X}
Mit Coco2D-X hat man die Wahl zwischen C++, Lua und JavaScript, welche für fast alle unterstützten Plattformen nutzbar sind. Einzige Einschränkung liegt bei JavaScript, denn diese lässt sich bei Cocos2D-X nicht mit Windows Phone verknüpfen \citep{cocos2d_main_features}. 

\bigskip
Lua ist eine von der Syntax simpel gehaltene Skriptsprache, mit objektorientierten Eigenschaften. Die geschriebenen Skripte werden durch einen Interpreter in Bytecode übersetzt und sind kompatibel mit der Sprache C. Lua befindet sich derzeit in Version 5.3 und wird häufig in der Spieleentwicklung eingesetzt \citep{lua_about}.

\bigskip
Mit der Unterstützung von C++ hat man die Möglichkeit, äußerst performante und portable Software zu schreiben, da diese direkt von C abgeleitet und kompatibel ist. C++ hat eine komplexere Syntax im Vergleich zu anderen High-Level Sprachen, zählt aber zu den schnellsten Programmiersprachen der Welt. Seit 1998 ist C++ ISO standardisiert und mit der aktuellen Version 14 verfügbar. Es werden zudem die prozeduralen, generischen und objektorientierten Programmierparadigmen unterstützt \citep{cplusplus}. 


\bigskip
Für Entwickler, die Erfahrungen im Webbereich besitzen, bietet die Verwendung von JavaScript, im Gegensatz zu C++, einen leichteren Einstieg in Cocos2D-X.
JavaScript ist eine Skriptsprache, die es seit 1995 gibt und für dynamisches HTML in Webbrowsern entwickelt wurde. Trotz der Namensähnlichkeit zu Java unterscheiden sich die beiden Sprachen grundlegend voneinander. JavaScript wird in der Regel genutzt, um in HTML Dokumenten clientseitige Logik zu ermöglichen. Mit der Programmiersprache Java können hingegen auch eigenständige Anwendungen aufgebaut werden. JavaScript folgt den Spezifikationen der privaten Normungsorganisation ECMA (European Computer Manufacturers Association), die Standardisierungen von Informationstechnologien entwickelt und die Richtigkeit deren Verwendung fördert, als auch eine frei zugängliche Veröffentlichung dazu liefert. Der standardisierte Kern von JavaScript wird als ECMAScript (ECMA 262) bezeichnet und beschreibt die Eigenschaften mit einer dynamischen Typisierung, die objektorientiert, aber klassenlose sind. Objekte basieren in JavaScript auf sogenannten Prototypen, die als Funktionen geschrieben werden. Nach der Instanziierung ist es möglich, das Objekt um zusätzliche Eigenschaften zu erweitern. Skripte können imperativ aber auch funktional aufgebaut werden. Geschriebene Skripte werden durch einen Interpreter übersetzt. Basierend auf JavaScript entstanden viele verschiedene Bibliotheken und Frameworks. Mit Node.js können dann beispielsweise serverseitige Netzwerkanwendungen betrieben werden. Durch Angular.js werden bekannte Entwurfsmuster aus der Softwareentwicklung zugänglich, die der Skriptsprache normalerweise verwehrt wären. ECMAScript befindet sich seit 2015 in Version 6 \citep{learning_javascript}.
 

\subsection{Unity3D}
In Unity3D finden die Sprachen C\#, UnityScript und Boo nutzerseitige Verwendung. Diese Sprachen entspringen Microsofts .NET Framework. Das bietet den Vorteil auch weitere .NET Sprachen benutzen zu können. Voraussetzung dafür ist, dass diese ihre Skripte in das DLL (Dynamically Linked Library) Format kompilieren können. Diese DLL Dateien können dann einem Unity Projekt hinzugefügt und verwendet werden \citep{unity_managed_plugins}. Für die Kompilierung nutzt Unity3D primär die Open Source Alternative zu .NET namens Mono.

\bigskip
Boo ist eine von Python beeinflusste Sprache für .NET als auch für Mono und verzichtet auf Klammern und Semikolons in der Syntax. Die Typisierung ist generell statisch, kann aber trotzdem dynamische \textit{Duck-Typing} Eigenschaften nutzen. Beim Duck-Typing werden Objekte nicht durch ihre Klasse typisiert, sondern durch die Art der vorhandenen Attribute und Methoden. Daher findet die Typisierung erst zur Laufzeit durch den Interpreter statt \citep{boo_about}. Der Name Duck-Typing entspringt dem sogenannten \textit{Ententest} zur allgemeinen Typisierung. Dieser Test wurde von einem Gedicht von James Whitcomb Riley inspiriert.

\bigskip
“\emph{When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.}” \citep{ducktest}


\bigskip
UnityScript wird innerhalb der eigenen Community, oft aber auch von dem Unternehmen selbst, fälschlicherweise mit JavaScript gleichgesetzt, so, als wären die beiden Sprachen äquivalent. Auch wenn syntaktische Ähnlichkeiten bestehen, gibt es große semantische Unterschiede.
UnityScript kann, wie die meisten objektorientierten Programmiersprachen, Klassen definieren und daraus Objekte erstellen. JavaScript hingegen besitzt zwar ebenfalls objektorientierte Eigenschaften, wobei aber, wie zuvor beschrieben, statt Klassen sogenannte Prototypes verwendet werden. Des Weiteren kann UnityScript, im Gegensatz zu JavaScript Klassen, Objekte, Funktionen und Variablen mit Zugriffsmodifikatoren/Sichtbarkeiten versehen. UnityScript wurde speziell für die Unity3D Engine konzipiert und ist proprietär, was das Finden genauer Spezifikationen erschwert \citep{unity_unityscript_vs_javascript}. 

\bigskip
C\# oder auch Visual C\# ist eine von Microsoft entwickelte Programmiersprache, die durch ECMA-334 standardisiert ist und sich aktuell in Version 6.0 befindet. Die Standardisierung bezieht sich allerdings nur auf die Sprache selbst und nicht auf Programme, die in Verbindung mit dem .NET Framework realisiert wurden. Die Syntax der objektorientierten Sprache weist große Ähnlichkeiten mit Java auf. Die Typisierung ist grundsätzlich statisch, wobei optional auch dynamische Typen genutzt werden können. Mit C\# können in Unity3D auch typische Softwarearchitekturen realisiert werden \citep{csharp_in_depth}. 
Laut einer eigenen Statistik von Unity3D sind etwa 80\% der Projekte in C\# geschrieben \citep{unity_languages}. 


\section{Entwicklungsumgebungen}
Für den Entwicklungsprozess besteht bei jedem Framework die Möglichkeit, zwischen mehreren IDEs wählen zu können. Praktisch kann jeder textbasierte Editor für die Programmierung der Anwendung verwendet werden. Aber um den Komfort von der passenden Hervorhebung der Syntax und die direkte Kompilierungsmöglichkeit des Basiscodes zu erhalten, empfiehlt es sich, auf die unterstützten Entwicklungsumgebungen zurückzugreifen. Diese sind bei den drei vorgestellten Spieleframeworks teilweise abhängig von dem verwendeten Betriebssystem des Entwicklers.

\subsection{Systembedingte Einschränkungen}
Für jedwede Erzeugung von iOS Applikationen gilt, dass die Apple IDE Xcode unumgänglich ist. Diese ist ausschließlich unter OS X Systemen erhältlich und einsetzbar. Um die iOS Applikation testen zu können, benötigt man seit Xcode 7 nur noch eine gültige Apple ID. Um die App zu veröffentlichen, ist der Erwerb einer Mitgliedschaft des Apple Developer Program verpflichtend. Diese wird mit aktuell 99 US Dollar jährlich berechnet. In der Mitgliedschaft sind die Rechte zur Veröffentlichung von iOS, watchOS und OS X Anwendungen enthalten sowie das Anlegen und Durchführen von Beta-Tests mit Testflight \citep{apple_developer_program}.

\bigskip
Um mit libGDX iOS Apps erstellen zu können, besteht die Bindung an einen speziellen Kompilierer, mit dem Java in Obective-C Code übersetzt werden kann. Hierfür wird mit RoboVM zusammengearbeitet. Die Einbindung dieses Kompilierers ist beispielsweise in Eclipse, Intellij IDEA und auf IDEA basierten Entwicklungsumgebungen möglich. Eine eigene IDE namens RoboVM Studio steht ebenfalls zur Wahl. Die Nutzung von RoboVM kostet derzeit 25 US Dollar bei einer Einzellizenz. Es werden aber auch reduzierte und kostenfreie Modelle für Indie Entwickler und Studenten angeboten \citep{roboVM}. 

\bigskip
Falls die Erstellung von Windows Phone Apps gefordert ist, wird die Verwendung von Visual Studio benötigt. Diese IDE setzt mindestens Windows 7 voraus. Um den Simulator nutzen zu können, wird Microsofts Virtualisierungstechnik Hyper-V vorausgesetzt. Hyper-V fordert wiederum  eine Windows 8 Pro oder Windows 10 Pro Version \citep{visual_studio}. 

\subsection{Unterstützte IDEs}
In Tabelle \ref{ides} werden die IDEs aufgelistet, die zur Bearbeitung des Quellcodes unterstützt und empfohlen werden. Abhängig davon, welche Programmiersprache man bevorzugt, hat man je Spieleframework mehrere IDEs zur Auswahl. Wie im vorigen Kapitel bereits erwähnt, ist Xcode mit OS X für jede iOS App verpflichtend, ebenso wie Visual Studio für Windows Phone Anwendungen nötig ist. Xcode kann bei Cocos2D-X für die Bearbeitung des Basiscodes verwendet werden, bei den anderen Frameworks nur für die Bearbeitung des kompilierten Codes. In der genannten Tabelle werden nicht alle unterstützten Programmiersprachen gelistet, sondern nur diejenigen, welche in Verbindung mit den Spieleframeworks relevant sind. Die jeweiligen Vor- und Nachteile der einzelnen Entwicklungsumgebungen werden in dieser Arbeit nicht weiter behandelt und auch nicht weiter vertieft, sondern dienen lediglich der Vollständigkeit.

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{cccccc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{IDE}}            & {\color[HTML]{FFFFFF} \textbf{Betriebssystem}} & {\color[HTML]{FFFFFF} \textbf{Sprache}} & {\color[HTML]{FFFFFF} \textbf{libGDX}} & {\color[HTML]{FFFFFF} \textbf{Cocos2D-X}} & {\color[HTML]{FFFFFF} \textbf{Unity3D}} \\
			{\color[HTML]{000000} \textbf{Eclipse}}        & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} Java}                        & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                   & {\color[HTML]{000000} }                 \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{IDEA}}           & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} Java}                        & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                   & {\color[HTML]{000000} }                 \\
			{\color[HTML]{000000} \textbf{Android Studio}} & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} Java}                        & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                   & {\color[HTML]{000000} }                 \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{NetBeans}}       & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} Java}                        & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                   & {\color[HTML]{000000} }                 \\
			{\color[HTML]{000000} \textbf{RoboVM Studio}}  & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} Java}                        & {\color[HTML]{000000} X}               & {\color[HTML]{000000} }                   & {\color[HTML]{000000} }                 \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Xcode}}          & {\color[HTML]{000000} OS X}                    & {\color[HTML]{000000} Obj-C / C++}                         & {\color[HTML]{000000}X}                & {\color[HTML]{000000} X}                  & {\color[HTML]{000000}X }                 \\
			{\color[HTML]{000000} \textbf{Cocos Code}}     & {\color[HTML]{000000} Windows / OS X}          & {\color[HTML]{000000} JavaScript / Lua}            & {\color[HTML]{000000} }                & {\color[HTML]{000000} X}                  & {\color[HTML]{000000} }                 \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Visual Studio}                         & Windows                                        & C\# / C++                                          &                                        & X                                         & X                                       \\
			\textbf{MonoDevelop}                           & Windows / OS X                                 & C\# / UnityScript                                  &                                        &                                           & X                                      
		\end{tabular}
	}
	\caption{Unterstützte Entwicklungsumgebungen zur Bearbeitung der Codebasis} \citep{libGDX_wiki, cocos2d_main_features, unity_code_editor}
	\label{ides}
\end{table}

\section{Native Gerätefunktionen und Schnittstellen}
Smartphones und Tablets besitzen in der Regel kaum oder gar keine Hardwarebuttons, die für Anwendungen mit einer neuen Funktionalität belegbar sind. Spiele, die für mobile Systeme entworfen wurden, greifen daher auf alternative Steuerungsmechanismen zurück.

\bigskip
Überwiegende Praxis ist es, den vorhandenen Touchscreen für Eingaben und Interaktionen zu nutzen. Dies kann über Gesten geschehen oder über die Virtualisierung von Aktionsflächen, wie zum Beispiel Buttons und Schieberegler. Alle drei Spieleframeworks verfügen über Möglichkeiten, verschiedene Touchgesten zu unterscheiden.
Eine weitere Möglichkeit in das Spielgeschehen eingreifen zu können bieten die geräteseitigen Sensoren. Zu den üblichen Sensoren gehören beispielsweise Gyroskop, Accelerometer und Kompass. Ein Anwendungsbeispiel für die Verwendung des Gyroskop Sensor wäre bei Rennspielen die Simulierung eines Lenkrads, wobei durch die Neigung des Gerätes gesteuert wird. Aber auch die Kamera fällt in diese Kategorie. Durch die Unterstützung von maschineller Bildverarbeitung können innerhalb von Echtzeitvideos Funktionalitäten hinterlegt werden. Ein Beispiel dafür sind Spiele mit Augmented Reality.

\bigskip
\textbf{Unity3D} liefert für fast alle gängigen Gerätefunktionen entsprechende Schnittstellen, um diese bei Bedarf mit Funktionalität zu hinterlegen \citep{unity_docs}. Bei \textbf{libGDX} kann auf die meisten Sensorentypen zugegriffen werden, ausschließlich der Kamera und GPS Lokalisierung \citep{libGDX_docs}. Im Vergleich zu den Anderen kann \textbf{Cocos2D-X} bisher nur den Accelerometer ansteuern, wenn dieser vorhanden ist. Gyroskop, Kamera, GPS und weiteres werden derzeit nicht offiziell unterstützt \citep{cocos2d_docs}. 

Dadurch, dass libGDX und Cocos2D-X quelloffen sind, ist bei Bedarf eine eigene Implementation dennoch möglich. In Tabelle \ref{tab_schnittstellen} werden die häufigsten Gerätefunktionen aufgelistet und die Unterstützung durch eine zugehörige Schnittstelle markiert. Der Punkt Netzwerkverbindung  ist so zu verstehen, dass keines der drei Spieleframeworks das WLAN Modul oder das mobile Internet selbstständig ein- und ausschalten kann. Aus Gründen der Sicherheit kann dies nur der Nutzer selbst. Es kann lediglich getestet werden, ob eine Verbindung zu einem Netzwerk vorhanden oder möglich ist. Für die Prüfung einer Bluetooth Verbindung gibt es derzeit für keines der drei Spieleframeworks eine offizielle Schnittstelle.

\begin{table}[htbp]
	\centering
	\resizebox{0.8\textwidth}{!}{%
		\begin{tabular}{
				>{\columncolor[HTML]{C0C0C0}}c ccc}
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Schnittstelle}} & \cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{libGDX}} & \cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Cocos2D-X}} & \cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Unity3D}} \\
			Touchgesten                                                         & X                                                              & X                                                                 & X                                                               \\
			Netzwerkverbindung                                                    & X                                                               & X                                                                   & X                                                               \\
			Accelerometer                                                         & X                                                              & X                                                                 & X                                                               \\
			Gyroskop                                                              & X                                                              &                                                                   & X                                                               \\
			Vibration                                                             & X                                                              &                                                                   & X                                                              \\
			Kompass                                                               & X                                                              &                                                                   & X                                                               \\
			Kamera                                                                &                                                                &                                                                   & X                                                               \\
			Geoposition                                                           &                                                                &                                                                   & X                                                               \\
			Bluetooth                                                             &                                                                &                                                                   &                                                                 \\
		\end{tabular}
	}
	\caption{Verfügbare Schnittstellen zu den Gerätefunktionen}
	\label{tab_schnittstellen}\citep{libGDX_docs,cocos2d_docs,unity_docs}
\end{table}


\section{Game Services}
Um die Motivation und die Wiederspielbarkeit zu erhöhen, können verschiedene, meist cloudbasierte, Services für optionale Spielinhalte eingebunden werden. Mit solchen Services können zum Beispiel Erfolgssysteme, Ranglisten und Mehrspielersysteme realisiert werden.
Ein Erfolgssystem basiert auf dem Belohnungsprinzip und kann den Benutzer auf unterschiedliche Weise in seinem Spielverhalten motivieren. Durch definierte Herausforderungen werden verschiedene Aufgaben gestellt, wobei dem Spieler durch das Erreichen dieser ein visuelles Feedback gegeben werden kann. Das kann beispielsweise in Form von Medaillen, Erhöhung des Spielerlevels oder einer Prozessleiste umgesetzt werden. Kompetitive Elemente können mit Bestenlisten erzielt werden, in denen bestimmte, spielinterne Metriken der Spieler sortiert aufgelistet werden können. Ranglisten über die höchste Punktzahl oder die längste Spielzeit geben dem Spieler Anreiz, sich zu verbessern und mit anderen zu messen. 
In Mehrspielermodi, die entweder rundenbasiert oder in Echtzeit ablaufen, treten zwei oder mehr Spieler gegeneinander an, um in einem Wettbewerb den besten Spieler zu ermitteln. Eine weitere Variante sind Modi, in denen die Teilnehmer kooperieren müssen, um Spielziele gemeinsam zu erreichen.
Um verbesserungswürdige Schwachstellen in der Anwendung zu ermitteln und das Verhalten von Spielern zu messen, werden Analysesysteme eingesetzt. Diese Systeme ermöglichen Einblicke auf Aktivitäten und Fortschritte der Spieler sowie Informationen zu getätigten Käufen innerhalb der Anwendung. Auch die Häufigkeit der Nutzung der Anwendung wird messbar. Diese Statistiken können zu einem besseren Verständnis der eigenen Anwendung verhelfen.
Für den Erwerb von zusätzlichen, anwendungsinternen Inhalten und die Abwicklung von Zahlungen, sind Shop Systeme notwendig. Dies wird bei plattformübergreifenden Applikationen durch die Implementierung einer Bibliothek ermöglicht, die zu den gewünschten Zielplattformen und zugehörigen Stores passende Schnittstellen bereitstellt. 
In Tabelle \ref{tab_game_services} werden APIs aufgelistet, die populäre Game Services in den Spieleframeworks unterstützen. Die Tabelle zeigt hauptsächlich APIs, die plattformübergreifende Eigenschaften aufweisen und auf den beiden Zielplattformen iOS und Android funktionieren. Die Cloudservices von Google Play Game Services, App42 und NextPeer bieten die meisten Schnittstellen zu den genannten Spielinhalten.

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{cccc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Game Service}}                                                               & {\color[HTML]{FFFFFF} \textbf{libGDX}}                                            & {\color[HTML]{FFFFFF} \textbf{Cocos2D-X}}                                         & {\color[HTML]{FFFFFF} \textbf{Unity3D}}                                           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Erfolge}}                                                                    & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             \\
			\cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} \textbf{Bestenlisten}}                                       & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Services \\ App42\end{tabular}             \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Multiplayer}}                                                                & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42 \\ Nextpeer\end{tabular} & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42 \\ Nextpeer\end{tabular} & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42 \\ Nextpeer\end{tabular} \\
			\cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} \textbf{Spielstand sichern}}                                 & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             & \begin{tabular}[c]{@{}c@{}}Play Game Services \\ App42\end{tabular}             \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Analyse}}                                                                    & App42                                                                             & App42                                                                             & \begin{tabular}[c]{@{}c@{}}Unity Analytics \\ App42 \\ Soomla\end{tabular}        \\
			\cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} \textbf{Shop System}}                                        & gdx-pay                                                                           & SDKBOX-IAP                                                                        & Soomla                                                                            \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{\begin{tabular}[c]{@{}c@{}}Soziale Netzwerke \\ Freundesliste\end{tabular}}} & \begin{tabular}[c]{@{}c@{}}App42 \\ Nextpeer\end{tabular}                         & \begin{tabular}[c]{@{}c@{}}App42 \\ Nextpeer\end{tabular}                         & \begin{tabular}[c]{@{}c@{}}Social API \\ App42 \\ Nextpeer \\ Soomla\end{tabular}
		\end{tabular}
	}
	\caption{Game Services und plattformübergreifende Schnittstellen}
	\label{tab_game_services}
\end{table}

\bigskip
\textbf{Play Game Services} \\
Das Framework von Google bietet zahlreiche, plattformübergreifende Services für den mobilen Gaming-Bereich. Die Voraussetzung für den Spieler, um diese Features nutzen zu können, ist ein Account in Googles Netzwerk Google+. Obwohl dies in der Tabelle nicht markiert wurde, bietet Play Game Services Werkzeuge zur Analyse des Spielerverhaltens an. Die Angaben von Google und den Spieleframeworks sind bezüglich der Unterstützung von Analysemöglichkeiten nicht eindeutig. Die Cloud Dienste von Google sind kostenfrei nutzbar. \citep{play_game_services}. 

\bigskip
\textbf{App42} \\
App42 von ShepHertz Technologies bietet ein umfangreiches Angebot an Cloudservices, die für Indieentwickler größtenteils kostenfrei zur Verfügung stehen. Es gibt Schnittstellen für eine Vielzahl an Plattformen und Frameworks, sowohl im nativen als auch im plattformübergreifenden Bereich \citep{app42}.

\bigskip
\textbf{NextPeer} \\
NextPeer bietet für die drei Spieleframeworks APIs zur Unterstützung von Multiplayer Spielen und für Anbindungen an soziale Netzwerke. Für die Nutzung steht ebenfalls eine kostenfreie Variante zur Auswahl \citep{nextpeer}.

\section{Produktvarianten}
Bei \textbf{libGDX} existieren keine weiteren, offiziellen Produktabspaltungen. Weitere populäre Derivate konnten nicht ermittelt werden, sondern nur Ableger, die aus privatem Bestrebungen entstanden sind. Die offizielle Community konzentriert sich daher hauptsächlich auf die Unterstützung und Weiterentwicklung der Hauptversion oder auf spezialisierte Module zur Erweiterung.

\bigskip
\textbf{Cocos2D-X} ist eine der offiziellen Abzweigungen aus der Cocos2D Familie. Die Basis bildet das mit Python entwickelte Cocos2D. Der erste, abgeleitete Ableger ist Cocos2D-iPhone oder auch bekannt als Cocos2D-ObjC. Diese Variante ist auf die Entwicklung mobiler Apple Geräte spezialisiert. Anwendungen können mit den plattformüblichen, nativen Sprachen Objective-C und Swift implementiert werden. Von dieser Version wurden wiederum weitere, spezialisierte Varianten abgeleitet. Dazu zählt Cocos2D-X, das die Unterstützung multipler Plattformen unterstützt. Die Ableger Cocos2D, -iPhone, -X, -HTML5 und der Editor SpriteBuilder gehören zu den offiziellen Projekten und werden durch ein koordiniertes Updateverhalten versorgt \citep{cocos2d_relationships}. 

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1\textwidth]{Bilder/Cocos2d_Relationships}
	\caption{Ableitungen und Varianten von Cocos2D}\label{graph_Cocos2d_Relationships}\citep{cocos2d_relationships}
\end{figure}

\bigskip
\textbf{Unity3D} bietet zwei Produktvarianten an, die Personal und die Professional Edition. Bei der Personal Edition handelt es sich um eine frei verfügbare Version, die für jeden nutzbar ist. Diese kann für Privatanwender, zu Bildungszwecken und für kommerzielle Zwecke benutzt werden. Bei der kostenfreien Version der Engine wird dem Nutzer keine der Basisfunktionalitäten vorenthalten. Sobald die grundlegenden Einnahmen eines Entwicklers oder Unternehmens mehr als 100.000 US-Dollar aus dem Vorjahr betragen, besteht die Verpflichtung, für den kommerziellen Gebrauch die Professional Edition zu verwenden. In dieser werden weitere Optionen auf zusätzliche Services freigeschaltet, wie Analyse Tools und cloudbasierte Projekte. In Tabelle \ref{Unity_Produkte} werden die Möglichkeiten beider Editionen aufgelistet. Das Kostenmodell der Professional Edition beginnt derzeit für ein Abonnement mit 75 US-Dollar pro Monat oder bei einer Einmalzahlung von 1.500 US-Dollar. Die mit der Einmalzahlung erworbene Dauerlizenz gilt nur für die aktuelle Version und deren Updates. Das bedeutet, dass bei dem Erwerb von Unity Professional 5 nicht automatisch die Nutzungsrechte für die darauf folgende Version 6 erhalten werden. Diese müssten dann in Form eines kostenpflichtigen Upgrades erfolgen. Weitere, optionale Erweiterungen können mit den iOS Pro und Android Pro Add-Ons erworben werden, die weitere Möglichkeiten zur Personalisierung der Anwendung ermöglichen. Professionelle Projektunterstützung und der Zugang zum Quellcode der Engine können durch zusätzliche, kostenpflichtige Pakete erworben werden \citep{unity_products}

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{cc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Edition}} & {\color[HTML]{FFFFFF} \textbf{Feature}}                                                                                               \\
			Professional / Personal                 & Game Engine inklusive aller Funktionen                                                                                                \\
			\rowcolor[HTML]{C0C0C0} 
			Professional / Personal                 & \begin{tabular}[c]{@{}c@{}}Unterstützung aller Plattformen\\ (ohne Zusatzlizenz Unity Splash Screen bei iOS und Android)\end{tabular} \\
			Professional / Personal                 & Lizenzfreiheit                                                                                                                        \\
			\rowcolor[HTML]{C0C0C0} 
			Professional                            & Unity Cloud Building                                                                                                                  \\
			Professional                            & Team Lizenz                                                                                                                           \\
			\rowcolor[HTML]{C0C0C0} 
			Professional                            & Game Performance Analyse                                                                                                              \\
			Professional                            & Keine Einkommensbeschränkung                                                                                                          \\
			\rowcolor[HTML]{C0C0C0} 
			Professional                            & Personalisierbarer Splash Screen                                                                                                      \\
			Professional                            & Unity Analytics zur Analyse des Spielerverhaltens                                                                                     \\
			\rowcolor[HTML]{C0C0C0} 
			Professional                            & Priorisierte Behandlung bei eingereichten Bugs                                                                                        \\
			Professional                            & Zugang zu Beta-Versionen                                                                                                              \\
			\rowcolor[HTML]{C0C0C0} 
			Professional                            & Unterstützung für zukunftige Plattformen                                                                                              \\
			Professional                            & Vergünstigungen im Asset Store                                                                                                       
		\end{tabular}
	}
	\caption{Gegenüberstellung von Personal und Professional Edition}
	\label{Unity_Produkte}\citep{unity_products}
\end{table}


\chapter{Konzeption und Implementierung einer Beispielapplikation}
Um die Möglichkeiten der gewählten Entwicklungstools tiefgehender analysieren zu können, sollten die theoretischen Informationen um praktische Erkenntnisse ergänzt werden. Demnach wird als Teil dieser Arbeit eine mobile Beispielapplikation konzipiert. Diese wird mit den gewählten Spieleframeworks plattformunabhängig umgesetzt, um somit Versionen für verschiedene Plattformen zu erzeugen. Die Anwendungsversion soll danach anhand von vereinbarten Metriken bemessen und analysiert werden. Die gewonnenen Resultate werden daraufhin in Zusammenhang mit den theoretischen Informationen komplementiert und die Entwicklungswerkzeuge als Ganzes verglichen. 

\section{Definition von Anforderungen}
\label{sec:definition_anforderungen}
Applikationen, aus Kategorien die den Schwerpunkt nicht auf Spiele legen, sondern beispielsweise auf Business und Unterhaltung, greifen in der Regel auf plattformspezifische Benutzeroberflächen zurück. Native Apps besitzen systembedingte, technische und optische Konventionen. Cross-Plattform Apps versuchen diese oft möglichst genau abzubilden und die Konventionen einzuhalten, um dem Benutzer ein natives Look-and-Feel zu bieten oder den Vorgaben der Stores nachzukommen. 
Meist folgen Spiele diesen Regeln nicht, da sie in Abhängigkeit des Spielprinzips auf unterschiedliche Eingabeelemente und UIs zurückgreifen. 
Das Spiel als solches ist ein komplexes Phänomen, das Forscher aus den unterschiedlichsten Fachbereichen beschäftigte und beschäftigt. Ein Teilbereich der Spielwissenschaft, genannt Ludologie (Die Lehre über das Spiel), befasst sich mit der Erforschung des Spielens und des digitalen Spielens \citep{ludologie}. 

\pagebreak

Die Forschungsinhalte beschäftigen sich unter anderem mit Fragestellungen aus den Bereichen:

\begin{itemize}
	\item Geschichte des digitalen Spielens
	\item Elemente des digitalen Spiels
	\item Begrifflichkeit zur Klassifizierung von Spielen und Genres
	\item Regeln und Spielmechanik
	\item u.v.m.
\end{itemize}


Wie wird der elementare Inhalt und den Umfang eines Computerspiels definiert?

\bigskip
Um nicht alle konkurrierenden Theorien zu berücksichtigen, wird hierfür beispielhaft die Gebrauchsdefinitionen von Salen und Zimmerman herangezogen:

\bigskip
\emph{„A game is a system in which players engage in an artificial conflict, defined by rules, that results in a quantifiable outcome.”} \citep[80]{salen_zimmerman}
\bigskip

Aus dieser Definition werden einige wesentliche Konzepte entnommen und von Salen und Zimmerman näher erläutert:

\bigskip
\textbf{Spieler}\\
Ein Spiel ist etwas, das ein oder mehrere Spieler aktiv spielen. Die Spieler interagieren mit dem System und Methoden des Spiels.

\bigskip
\textbf{Konflikt}\\
Der Konflikt bezeichnet den Wettkampfcharakter eines Spiels. Dieser kann verschiedene Formen annehmen, wie kompetitive Elemente oder der Konflikt gegen das Spielsystem selbst. 

\bigskip
\textbf{Regeln}\\
Die Regeln liefern die Struktur des Spiels, indem sie festlegen, was der Spieler machen kann und was nicht.

\bigskip
\textbf{Quantifizierbares Ziel}\\
Das Ergebnis eines Spiels ist entweder, dass der Spieler gewonnen oder verloren hat, oder eine Form eines Erfolgsfaktors erhält. Dieser Erfolgsfaktor kann sich beispielsweise durch ein höheres Level oder eine Art Punktzahl bemerkbar machen. 

\bigskip
Anhand dieser Definitionen werden die Anforderungen für die Beispielapplikation konkretisiert:

\begin{itemize}
	\item Es soll eine Spielfigur vorhanden sein, auf die der Spieler Einfluss nehmen kann.
	\item Die Spielfigur soll auf Hindernisse treffen, die die Aktionen des Spielers beeinflussen können.
	\item Das Spiel gilt als gewonnen, wenn ein definiertes Ziel erreicht oder das Spiel nicht beendet wird.
	\item Der Spieler verliert, wenn eine definierte Anzahl an Fehlversuchen erreicht werden, das Spiel abgebrochen wird oder andere Aktionen ausgeführt werden, die gegensätzlich zum Gewinnen des Spiels stehen.
	\item Der Spieler soll einen Erfolgsfaktor erhalten, um seine Spielweise zu messen.
\end{itemize}

Darüber hinaus werden weitere allgemeine Anforderungen gestellt, die häufig in Spielen enthalten sind:

\begin{itemize}
	\item Das Spiel soll einen visuellen Charakter haben und Grafiken verwenden.
	\item In dem Spiel sollen Animationen vorkommen, wie Bewegungen. 
	\item Das Spiel soll über Audioelemente verfügen, wie Musik oder Soundeffekte.
	\item Es sollen mehrere Spielszenen verwendet werden.
	\item Ein Spielobjekt soll in allen Szenen verfügbar sein und seinen Status beibehalten.
\end{itemize}

Die Applikation soll zudem möglichst simpel gehalten werden, um sie anhand der einfachsten und elementarsten Eigenschaften zu bemessen.


\section{Spielidee}
Ein mobiles Spiel, das mitunter durch seine Einfachheit in kürzester Zeit großen Erfolg erlangte, ist das Spiel Flappy Bird \citep{flappy_bird}.
In diesem Spiel steuert der Spieler durch das Antippen des Touchscreens die Flughöhe eines Vogels, um ihn vor dem Aufprall auf den Boden zu bewahren und durch entgegenkommende Hindernisse zu manövrieren. Hierbei handelt es sich um eine Art Endlos-Spiel, das sich dadurch auszeichnet, dass der Spieler solange spielt, bis er verliert. Ein Spiel wird verloren, wenn die Spielfigur mit einem anderen Objekt kollidiert. Es verfügt zudem über eine Punktzahl, die sich erhöht, wenn der Vogel erfolgreich die Hindernisse passiert hat.

\bigskip
In Anlehnung an Flappy Bird entstanden zahlreiche Spiele, die auf dieser Spielidee basieren. Dieses Spielprinzip wird häufig als Vorlage verwendet, um beispielhaft den Einstieg in die Spielentwicklung mit einer bestimmten Engine oder einem Framework zu erlernen. Da alle vorher genannten Anforderungen in dieses Spielprinzip hineinpassen, wurde für diese Arbeit ein Spiel konzipiert, das sich an dieser Vorlage orientiert. Das Spiel trägt den Titel: \textbf{Happy Bird}. 

\section{Spielfluss}
Das Spielprinzip und der Spielfluss bei Happy Bird sind einfach zu verstehen. Das Spiel ist auf den Portrait-Modus (Hochformat) festgelegt und für die spätere Analyse wird durchgängig eine Anzeige mit der aktuellen Framerate dargestellt.


\begin{enumerate}
	\item Das Spiel wird über das App Icon gestartet.
	\item Direkt nach dem Start wird ein Logo des jeweiligen Frameworks oder Engine angezeigt.
	\item Daraufhin wird ein Hauptmenü dargestellt, das den Titel des Spiels, Hintergrundgrafiken und einen Startbutton anzeigt. Die Hintergrundmusik wird abgespielt.
	\item Bei betätigen des Startbuttons wird in die Spielszene gewechselt.
	\item Die Spielszene beginnt mit den Hintergrundgrafiken und zeigt einen Vogel als Spielfigur.
	\item Der Vogel verliert an Höhe, wenn der Spieler nichts tut und steigt bei Berührung des Touchscreens an.
	\item In einem festgelegten Intervall kommen der Figur Hindernisse in Form von grünen Röhren entgegen. Diese besitzen eine Lücke, durch die der Vogel hindurchmanövriert werden soll. Die Position der Lücke befindet sich in einer zufälligen, vertikalen Stelle innerhalb der Sichtbarkeit.
	\item Wenn der Vogel erfolgreich ein Hindernis passiert hat, erhält der Spieler einen Punkt, der oben links im Spiel zu der Gesamtpunktzahl hinzugefügt und dargestellt wird.
	\item Das Spiel endet und gilt als verloren, wenn der Vogel mit einem der entgegenkommenden Hindernisse oder dem Boden kollidiert.
	\item Der obere Rand der Spielszene wird durch eine unsichtbare Wand begrenzt und kann nicht passiert werden.
	\item Bei verlorenem Spiel wird in das Game Over Menü gewechselt das vom Aufbau dem Hauptmenü entspricht. In dieser Szene wird der Game Over Status angezeigt. Über den Startbutton kann ein neues Spiel gestartet werden.
\end{enumerate}


Die in Kapitel \ref{sec:definition_anforderungen} definierten Anforderungen werden durch die Spielidee und den Spielfluss somit komplett umgesetzt. Die Spielfigur wird mit Hilfe einer Spritesheet-Animation animiert und ist durch Berührung des Touchscreen steuerbar. Es werden Hindernisse erzeugt, die bei Kollision das Spielende hervorrufen. Der Spieler hat die Möglichkeit Punkte zu erhalten.
Die Hintergrundmusik wird in allen drei Spielszenen gespielt. Sie startet bei Wechsel der Szene nicht von vorne, behält einen globalen Status bei und läuf in einer Endlosschleife. Das Spiel wird komplett in 2D gehalten. Auf weitere, optionale Spielinhalte wird verzichtet, da diese für eine Testapplikation unnötig sind.


\section{Verwendete Werkzeuge}
In diesem Kapitel werden die genutzten Softwarewerkzeuge in Tabelle \ref{genutzte_software} aufgelistet, die bei der Entwicklung der Testapplikation eingesetzt wurden. Für die Versionierung der Projekte wurde Git verwendet.

\begin{table}[htbp]
	\centering
	\resizebox{0.8\textwidth}{!}{%
		\begin{tabular}{ccc}
			& \cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Betriebssystem}} & \cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Version}}                  \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Betriebssysteme}}                                                  &                                                                        &                                                                                  \\
			\textbf{Mac OS X}                                                                                                        & Mac OS X                                                               & 10.10.5                                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Windows}                                                                                                         & Windows                                                                & \begin{tabular}[c]{@{}c@{}}Windows 8.1\\  Standard Edition\\ 64-Bit\end{tabular} \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{\begin{tabular}[c]{@{}c@{}}Game-\\ Framework/Engine\end{tabular}}} &                                                                        &                                                                                  \\
			\textbf{libGDX}                                                                                                          & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            & 1.9.2                                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Cocos2D-X}                                                                                                       & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            &     3.9                                                                             \\
			\textbf{Unity3D}                                                                                                         & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            & 5.3.2f1                                                                          \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Programmiersprache}}                                               &                                                                        &                                                                                  \\
			\textbf{Java}                                                                                                            & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            &  1.8.0                                                                                \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{C++}                                                                                                             & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &   11                                                                               \\
			\textbf{C\#}                                                                                                             & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &  3.0                                                                                \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Objective-C}                                                                                                     & Mac OS X                                                               &    2.0                                                                              \\
			\textbf{Python}                                                                                                          & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &      2.7.11                                                                             \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Entwicklungsumgebung}}                                             &                                                                        &                                                                                  \\
			\textbf{Xcode}                                                                                                           & Mac OS X                                                               &  7.2.1                                                                                \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Android Studio}                                                                                                  & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &   1.3.1                                                                               \\
			\textbf{Visual Studio}                                                                                                   & Windows                                                                &  14.0.24720                                                                                \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Monodevelop}                                                                                                     & \begin{tabular}[c]{@{}c@{}}Windows, \\ Mac OS X\end{tabular}           & 5.9.6                                                                                 \\
			\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Sonstiges}}                                                        &                                                                        &                                                                                  \\
			\textbf{Android SDK}                                                                                                     & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            & 6.0                                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{Android NDK}                                                                                                     & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            &  r10e                                                                                \\
			\textbf{Apache Ant}                                                                                                     & \begin{tabular}[c]{@{}c@{}}Mac OS X,\\ Windows\end{tabular}            & 1.9.6                                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			\textbf{.NET/Mono}                                                                                                            & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &  2.0                                                                                \\
			\textbf{RoboVM}                                                                                                          & \begin{tabular}[c]{@{}c@{}}Mac OS X, \\ Windows\end{tabular}           &   1.13.0                                                                              
		\end{tabular}
	}
	\caption{Eingesetzte Software auf den jeweiligen Betriebssystemen und Versionen}\label{genutzte_software}
\end{table}

\section{Eingesetzte Komponenten}
\label{sec:eingesetze_komponenten}
Bei den eingesetzten und benötigten Komponenten existieren geringe Unterschiede. Um eine Sprite-Animation in Cocos2D und libGDX zu ermöglichen, empfehlen die Frameworks die Nutzung von Spritesheets in Kombination mit einer Property List-Datei (.plist). Bei einem Spritesheet handelt es sich um eine Sammlung von Grafiken in einer Datei. Diese Grafiken können allein oder in einer zusammenhängenden Abfolge stehen. Diese werden dann der Größe entsprechend ausgeschnitten.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{bilder/Red_Bird}
	\caption{Spritesheet für die Animation der Spielfigur in Happy Bird}\label{spritesheet}
\end{figure}

Durch Zuhilfenahme der Property List (Liste von Eigenschaften) die in Zusammenhang mit dem Spritesheet erstellt werden kann, können Informationen über die einzelnen Sprites ausgelesen werden. Diese geben Auskunft über Namen, Größe, Offset, Skalierung und Rotation der einzelnen Grafiken auf dem Spritesheet und sind auf Basis von XML-Dateien gespeichert oder binär kodiert. Innerhalb der Anwendung können die einzelnen Grafiken dann in einer einstellbaren Geschwindigkeit und Dauer nacheinander angezeigt werden. Diese Art von Animation ähnelt einem Daumenkino.
In Unity3D können ebenfalls Spritesheets genutzt werden, jedoch werden die Property Lists für die Teilung und den Informationshintergrund nicht benötigt. Komfortable Möglichkeiten bieten die sogenannten Prefabs. Ein Prefab kann spezifisch definierte Informationen und Eigenschaften über ein oder mehrere Gameobjekte tragen und diese in einem Objekt abrufbereit verfügbar machen. In Happy Bird werden die Pipe-Hindernisse beispielsweise als Prefab definiert, mit den Informationen zu den Grafiken, Positionen und Kollisionsboxen.
Für die Erstellung der Grafiken und Animationen wurde der freie Online-Spriteeditor Piskel verwendet \citep{piskel}. 
Die verwendete Hintergrundmusik in Happy Bird stammt von dem amerikanischen Komponisten und Musikproduzenten Kevin MacLeod. Das Musikstück mit dem Titel \emph{"Monkeys Spinning Monkeys"} ist unter der Creative Commons lizensiert und frei verfügbar \citep{macLeod}. 
In Tabelle \ref{spiel_komponenten} werden die Hauptkomponenten mit ihren Eigenschaften sowie einige Framework-abhängige Dateien aufgelistet.

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{ccccc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} Dateiname}   & {\color[HTML]{FFFFFF} Dateityp} & {\color[HTML]{FFFFFF} Objekttyp}     & {\color[HTML]{FFFFFF} Verwendung}       & {\color[HTML]{FFFFFF} Dateigröße (KB)} \\
			{\color[HTML]{000000} Red\_Bird}   & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Spritesheet}   & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}1,54}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} bird\_plist}        & {\color[HTML]{000000} PLIST}    & {\color[HTML]{000000} Property List} & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}1,63}           \\
			{\color[HTML]{000000} sprite\_1}   & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}0,44}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} sprite\_2}   & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}0,4}           \\
			{\color[HTML]{000000} sprite\_3}   & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}0,39}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} sprite\_4}   & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Spielfigur}       & {\color[HTML]{000000}0,4}           \\
			{\color[HTML]{000000} Sky}         & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Hintergrund}      & {\color[HTML]{000000}11,8}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} Ground}      & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Hindernis}        & {\color[HTML]{000000}3,05}           \\
			{\color[HTML]{000000} Pipe}        & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Hindernis}        & {\color[HTML]{000000}1,99}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} StartButton} & {\color[HTML]{000000} PNG}      & {\color[HTML]{000000} Sprite}        & {\color[HTML]{000000} Button}           & {\color[HTML]{000000}6,98}           \\
			{\color[HTML]{000000} Marker Felt} & {\color[HTML]{000000} TTF}      & {\color[HTML]{000000} Font}          & {\color[HTML]{000000} Schrift}          & {\color[HTML]{000000}26}           \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} Arial}       & {\color[HTML]{000000} TTF}      & {\color[HTML]{000000} Font}          & {\color[HTML]{000000} Schrift}          & {\color[HTML]{000000}761}           \\
			{\color[HTML]{000000} BGMusic}     & {\color[HTML]{000000} MP3}      & {\color[HTML]{000000} Audio}         & {\color[HTML]{000000} Hintergrundmusik} & {\color[HTML]{000000}4770}          
		\end{tabular}
	}
	\caption{Liste von eingesetzten Spielelementen und deren Eigenschaften}
	\label{spiel_komponenten}
\end{table}

\section{Programmierung}
Für die Entwicklung wurde den Anforderungen entsprechend C++ bei Cocos2D-X, C\# bei Unity3D und Java bei libGDX für die Codebasis gewählt. Mit welcher Programmiersprache die schnellsten und effizientesten Ergebnisse erzielt werden können, steht in Verbindung mit der Vorerfahrung eines Entwicklers. Aber auch die Unterstützung durch eine qualitativ hochwertige Dokumentation und praktische Beispiele beeinflussen den Entwicklungsfortschritt. Für die Programmierung wurden die offiziellen Dokumentationen und Anleitungen zur Unterstützung verwendet. Es wurde zudem versucht, für die korrekte Darstellung alle gängigen Displaygrößen zu unterstützen. Die Darstellung konnte aber mangels Auswahl an Testgeräten nur innerhalb des Simulators getestet werden.


\chapter{Analyse der Test-Applikationen}
\label{sec:analyse_der_apps}

\section{Definition von Metriken}
Die erstellten Applikationen sollen näher analysiert und verglichen werden. Um dies möglichst objektiv und repräsentativ durchzuführen, werden vergleichbare Metriken definiert. Diese Metriken bilden anschließend den inhaltlichen Kern für das Messprotokoll in Kapitel \ref{sec:messprotokol}. Weiterhin muss für jede Metrik der Ablauf der Messung sowie der Ausgangszustand der verwendeten Testgeräte normiert werden.

\bigskip
\textbf{Ausgangsgröße einer Basisapplikation} \\
Eine Basisapplikation ist eine Anwendung, die bei Anlegung eines neuen Projekts erzeugt wird. Dies ist eine App mit einer automatisch erzeugten Szene/View und soll dem Zweck dienen, eine Vorstellung über die Ausgangsgröße einer unveränderten, minimalen Applikation zu geben. Dieser Messwert soll das Verhältnis von Ausgangsgröße zur Gesamtgröße des erstellten Spiels anschaulicher darstellen. Für die Messung wird jeweils ein neues Projekt angelegt, die notwendigen Einstellungen für die mobile Unterstützung vorgenommen und daraus Applikationen erzeugt. Danach wird die Größe der installierten Anwendung auf dem Testgerät dokumentiert. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Megabyte angegeben.

\bigskip
\textbf{Gesamtgröße des Spiels} \\
Dies beschreibt einen Messwert, der die Gesamtgröße des Spiels inklusive aller erstellten und hinzugefügten Inhalte beschreibt. Es werden alle genutzten Ressourcen, Bibliotheken und sonstige Dateien hinzugezählt. Für die Messung wird die Größe der installierten Applikationen auf den Testgeräten dokumentiert. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Megabyte angegeben.

\bigskip
\textbf{Größe der Ressourcen} \\
Die Ressourcen sind die in Kapitel \ref{sec:eingesetze_komponenten} deklarierten Komponenten. Hierzu zählt die Schnittmenge der Komponenten, die einheitlich in allen Projekten verwendet werden, sowie zusätzlich jene Bestandteile, die in Abhängigkeit zu einem Spieleframework stehen. Für die Messung wird die unkomprimierte Größe der individuellen Ressourcenordner innerhalb der Projekte dokumentiert. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Megabyte angegeben.

\bigskip
\textbf{Benötigter Arbeitsspeicher} \\
Dieser Messwert dokumentiert die Größe des belegten Arbeitsspeichers zur Laufzeit. Auf den mobilen Testgeräten von Android ist die Messung während der laufenden Anwendung nicht gleichzeitig möglich. Für die Erfassung des Werts muss die Applikation verlassen werden und aus den Systemeinstellungen abgelesen werden. Währenddessen bleibt die App im Hintergrund aktiv. Bei iOS Geräten kann aus den Laufzeitanalyse-Tools von Xcode abgelesen werden. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Megabyte angegeben.

\bigskip
\textbf{Ladegeschwindigkeit bei Neustart} \\
Die Ladegeschwindigkeit ist die gemessene Zeit zwischen der Betätigung des Starticons und der Bereitschaft der Menüszene. Die Dauer der Anzeige des Splashscreens wurde gemäß der Grundeinstellungen der Projekte übernommen und bildet die Zeit ab, in der die Anwendung geladen wird. Hierfür wird vorausgesetzt, dass die Applikation nicht im Hintergrund aktiv ist. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Sekunden angegeben.

\bigskip
\textbf{Frames pro Sekunde} \\
Die Berechnung und Darstellung der Framerate wurde dem Spiel manuell hinzugefügt. Dieser Wert wird innerhalb der Spielszenen dargestellt und während des Spielflusses beobachtet. Hierbei wird der Durchschnittswert dokumentiert. Falls es zu eventuellen, auffälligen Schwankungen kommen sollte und diese den Spielfluss beeinträchtigen, wird eine entsprechende Bemerkung im Abschluss dazu gegeben. Ein hoher, stabiler Wert gilt als positiv und ein niedriger, schwankender als negativ. Der Wert wird in durchschnittlichen Frames pro Sekunde angegeben.

\bigskip
\textbf{Akkuverbrauch} \\
Der Akkuverbrauch wird über einen Zeitraum von 15 Minuten gemessen. Ausgangswert ist ein vollständig geladenes Testgerät mit 100\% Ladezustand. Das Spiel wird über den Messzeitraum durchgehend genutzt. Dokumentiert wird anschließend der prozentuale Akkuverbrauch. Ein niedriger Wert gilt als positiv und ein hoher als negativ. Der Wert wird in Prozent angegeben.

\bigskip
\textbf{Mindestanforderung des Systems} \\
Dies gibt die minimalen Anforderungen der mobilen Betriebssystemversion an. Die Unterstützung von älteren Versionen wird hierbei als vorteilhaft beurteilt, weil dadurch eine größere Zielgruppe erreicht werden kann. Der Wert entspricht der Versionsnummer für die Mindestanforderung des Systems. Die Versionsnummer kann bei Android in Tabelle \ref{tab_android_vers} und bei iOS in Tabelle \ref{tab_ios_vers} verglichen werden.

\bigskip
\textbf{Codezeilen} \\
Die Menge der Codezeilen ist nicht unbedingt eine vergleichbare Metrik, da diese in Abhängigkeit des Programmierstils, der Erfahrung des Entwicklers, der Programmiersprache, der Architektur, des Einsatzes von Kommentaren und der Verwendung von leeren Zeilen abhängig ist. Jedoch soll hierdurch ein grober Eindruck über den benötigten Code und damit verbundenen Aufwand vermittelt werden. Ein niedriger Wert gilt als positiv und ein hoher als negativ.


\section{Testgeräte und Voreinstellungen}
Die Applikationen werden auf Smartphones mit Android und iOS System getestet. Die relevanten Gerätedaten der verwendeten Testgeräte sind in Tabelle \ref{testgeraete} aufgelistet. Falls zur Reproduktion ein anderes Testgerät verwendet werden soll, kann in der Tabelle \ref{tab_android_vers} für Android und Tabelle \ref{tab_ios_vers} für iOS die Version des Betriebssystem für die Mindestanforderung verglichen werden. Um die zu dokumentierenden Messwerte möglichst unverfälscht aufnehmen zu können, werden die Geräte vor der Durchführung der Messung einheitlich konfiguriert. Dies ist notwendig, um Daten wie Akkuverbrauch, Arbeitsspeicher oder Framerate möglichst wenig zu beeinflussen und die Ergebnisse reproduzierbarer zu machen. 

\begin{itemize}
	\item Alle Verbindungsoptionen (WLAN, mobiler Datenverkehr, Bluetooth, GPS, …etc.) werden deaktiviert.
	\item Die Bildschirmhelligkeit wird auf 50\% gestellt.
	\item Die Lautstärke für Medien und Anwendungen wird auf 50\% gestellt und alle anderen Töne deaktiviert.
	\item Alle weiteren Anwendungen und Prozesse werden weitestgehend beendet.
	\item Das Gerät wird in den Flug-Modus gesetzt, um die Verbindungsversuche zu einem Provider zu unterbinden.
	\item Das Spiel wird auf dem internen Speicher installiert.
\end{itemize}

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{ccc}
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Technische Daten}}       & {\color[HTML]{FFFFFF} \textbf{Android}}                                                          & {\color[HTML]{FFFFFF} \textbf{iOS}}                                                             \\
			{\color[HTML]{000000} \textbf{Hersteller}}             & {\color[HTML]{000000} Samsung}                                                                   & {\color[HTML]{000000} Apple}                                                                    \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Modell}}                 & {\color[HTML]{000000} Galaxy S5+}                                                                & {\color[HTML]{000000} iPhone 4S}                                                                 \\
			{\color[HTML]{000000} \textbf{Artikelname}}            & {\color[HTML]{000000} G901F}                                                                     & {\color[HTML]{000000}- }                                                                         \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Betriebssystem}}         & {\color[HTML]{000000} Android 5.0.2 }                                                                          & {\color[HTML]{000000} iOS 9.2 }                                                                         \\
			{\color[HTML]{000000} \textbf{System-on-a-Chip (SoC)}} & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Qualcomm Snapdragon 805\\ APQ8084\end{tabular}} & {\color[HTML]{000000} Apple A5}                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Prozessor}}              & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Krait 450\\ 2500 MHz\\ 4 Kerne\end{tabular}}    & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}ARM Cortex A9\\ 800 MHz\\ 2 Kerne\end{tabular}} \\
			{\color[HTML]{000000} \textbf{Grafikprozessor}}        & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}Qualcomm Adreno 420\\ 600 MHz\end{tabular}}     & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}PowerVR SGX 543MP\\2 x 200 MHz\end{tabular}}        \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Arbeitsspeicher}}        & {\color[HTML]{000000} 2 GB}                                                                      & {\color[HTML]{000000} 512 MB}                                                                   \\
			{\color[HTML]{000000} \textbf{Displaygröße}}           & {\color[HTML]{000000} 5,1 Zoll}                                                                  & {\color[HTML]{000000} 3,5 Zoll}                                                                 \\
			\rowcolor[HTML]{C0C0C0} 
			{\color[HTML]{000000} \textbf{Auflösung}}              & {\color[HTML]{000000} 1080 x 1920 Pixel}                                                         & {\color[HTML]{000000} 640 x 960 Pixel}                                                          \\
			{\color[HTML]{000000} \textbf{Akku}}                   & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}2800 mAh\\ Li-Ion\end{tabular}}                 & {\color[HTML]{000000} \begin{tabular}[c]{@{}c@{}}1420 mAh \\ Li-Ion\end{tabular}}              
		\end{tabular}
	}
	\caption{Datenblatt der Android und iOS Testgeräte}
	\label{testgeraete}
\end{table}

Bei den eingesetzten Smartphones handelt es sich um gebrauchte Geräte, was bedeutet, dass manche Leistungsmerkmale zu baugleichen Modellen abweichen können. Da es bei Smartphones mit Android und iOS eine sehr große Vielfalt an verschiedensten Geräten, Versionen und Ausstattungen gibt, kann die fehlerfreie Funktion des Spiels nur theoretisch garantiert werden. Um die Darstellung in den unterschiedlichen Auflösungen zu testen, wurden zusätzlich die Simulatoren von Xcode und Android Studio zu Hilfe gezogen.

\section{Messprotokoll}
\label{sec:messprotokol}
In diesem Teil der Arbeit werden die Messergebnisse zu den vorher definierten Metriken, in Zusammenhang mit den angegebenen Testgeräten, aufgelistet. In Tabelle \ref{protokoll_android} sind die Ergebnisse der Android Version und in Tabelle \ref{protokoll_ios} die der iOS Version zu sehen.

\bigskip
Erläuterung zu den Einträgen:

Bestes Ergebnis = Hervorgehoben (fett)\\
Teilergebnis (unfertig) = Stern (*)\\
Kein Messergebnis = Strich (-)

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{ccccc}
			\rowcolor[HTML]{000000} 
			\multicolumn{5}{c}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Happy Bird - Android}}}                                                                                                                                                                                 \\
			\rowcolor[HTML]{000000} 
			\multicolumn{5}{l}{\cellcolor[HTML]{000000}{\color[HTML]{000000} }}                                                                                                                                                                                                              \\
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Metrik}}                                                                      & {\color[HTML]{FFFFFF} \textbf{Wert}}  & {\color[HTML]{FFFFFF} \textbf{libGDX}} & {\color[HTML]{FFFFFF} \textbf{Cocos2D}} & {\color[HTML]{FFFFFF} \textbf{Unity3D}} \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ausgangsgröße \\ einer Basisapplikation\end{tabular}}} & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{\textbf{8,12}}                  & \multicolumn{1}{c|}{14,63}                   & \multicolumn{1}{c|}{29,09}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Gesamtgröße \\ des Spiels\end{tabular}}}            & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{*13,4}                  & \multicolumn{1}{c|}{\textbf{19,7}}                   & \multicolumn{1}{c|}{32,66}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Größe der Ressourcen}}                                                         & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{5,9}                  & \multicolumn{1}{c|}{5,9}                   & \multicolumn{1}{c|}{\textbf{4,9}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Benötigter Arbeitsspeicher}}                                                   & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{*22,97}                  & \multicolumn{1}{c|}{\textbf{41,73}}                   & \multicolumn{1}{c|}{113,63}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ladegeschwindigkeit \\ bei Neustart\end{tabular}}}  & \multicolumn{1}{c|}{Sekunden}         & \multicolumn{1}{c|}{1.16}                  & \multicolumn{1}{c|}{\textbf{0,85}}                   & \multicolumn{1}{c|}{3,02}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Frames pro Sekunde}}                                                           & \multicolumn{1}{c|}{Frames / Sekunde} & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{\textbf{60}}                   & \multicolumn{1}{c|}{\textbf{60}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Akkuverbrauch}}                                                                & \multicolumn{1}{c|}{Prozent} & \multicolumn{1}{c|}{5}                  & \multicolumn{1}{c|}{5}                   & \multicolumn{1}{c|}{5}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Mindestanforderung des Systems}}                                                                             & \multicolumn{1}{c|}{Versionsnummer}                 & \multicolumn{1}{c|}{\textbf{2.3}}                  & \multicolumn{1}{c|}{\textbf{2.3}}                   & \multicolumn{1}{c|}{\textbf{2.3}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Codezeilen}}                                                                             & \multicolumn{1}{c|}{Zeilen}                 & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{340}                   & \multicolumn{1}{c|}{\textbf{104}}                   \\ \hline
		\end{tabular}
	}
	\caption{Messprotokoll des Spiels auf Android}\label{protokoll_android}
\end{table}

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{ccccc}
			\rowcolor[HTML]{000000} 
			\multicolumn{5}{c}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Happy Bird - iOS}}}                                                                                                                                                                                 \\
			\rowcolor[HTML]{000000} 
			\multicolumn{5}{l}{\cellcolor[HTML]{000000}{\color[HTML]{000000} }}                                                                                                                                                                                                              \\
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Metrik}}                                                                      & {\color[HTML]{FFFFFF} \textbf{Wert}}  & {\color[HTML]{FFFFFF} \textbf{libGDX}} & {\color[HTML]{FFFFFF} \textbf{Cocos2D}} & {\color[HTML]{FFFFFF} \textbf{Unity3D}} \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ausgangsgröße \\ einer Basisapplikation\end{tabular}}} & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{48,9}                  & \multicolumn{1}{c|}{\textbf{7,2}}                   & \multicolumn{1}{c|}{22,4}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Gesamtgröße \\ des Spiels\end{tabular}}}            & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{*54,4}                  & \multicolumn{1}{c|}{\textbf{13,9}}                   & \multicolumn{1}{c|}{38,8}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Größe der Ressourcen}}                                                         & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{5,9}                  & \multicolumn{1}{c|}{5,9}                   & \multicolumn{1}{c|}{\textbf{4,9}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Benötigter Arbeitsspeicher}}                                                   & \multicolumn{1}{c|}{MB}               & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{\textbf{20,3}}                   & \multicolumn{1}{c|}{42,7}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ladegeschwindigkeit \\ bei Neustart\end{tabular}}}  & \multicolumn{1}{c|}{Sekunden}         & \multicolumn{1}{c|}{2,18}                  & \multicolumn{1}{c|}{\textbf{1,43}}                   & \multicolumn{1}{c|}{7,62}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Frames pro Sekunde}}                                                           & \multicolumn{1}{c|}{Frames / Sekunde} & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{\textbf{60}}                   & \multicolumn{1}{c|}{30}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Akkuverbrauch}}                                                                & \multicolumn{1}{c|}{Prozent} & \multicolumn{1}{c|}{0}                  & \multicolumn{1}{c|}{0}                   & \multicolumn{1}{c|}{0}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Mindestanforderung des Systems}}                                                                             & \multicolumn{1}{c|}{Versionsnummer}                 & \multicolumn{1}{c|}{\textbf{6.0}}                  & \multicolumn{1}{c|}{\textbf{6.0}}                   & \multicolumn{1}{c|}{\textbf{6.0}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Codezeilen}}                                                                             & \multicolumn{1}{c|}{Zeilen}                 & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{340}                   & \multicolumn{1}{c|}{\textbf{104}}                   \\ \hline
		\end{tabular}
	}
	\caption{Messprotokoll des Spiels auf iOS}\label{protokoll_ios}
\end{table}


\section{Auswertung der Messergebnisse}
Die dokumentierten Messergebnisse aus Kapitel \ref{sec:messprotokol} sollen nun anhand der gemessenen Metriken verglichen werden. Das Ergebnis jeder Metrik wird nachfolgend erläutert, wobei einerseits die plattformabhängigen, als auch die gemeinsamen, plattformübergreifenden Daten, berücksichtigt werden.  Die Beispielapplikation konnte mit Cocos2D-X und Unity3D den Anforderungen nach umgesetzt werden. Die App konnte lediglich mit libGDX nicht final abgeschlossen werden, weshalb die Messergebnisse von diesem Framework nur den erreichten Stand abbilden. Es existiert die Spielszene inklusive des steuerbaren Vogels und Hindernisse, jedoch fehlen die Kollisionsabfragen, die Punktedarstellung, Hintergrundmusik und Szenenwechsel. Diese Ergebnisse geben dennoch eine ausreichende Einschätzung, um in den Vergleich miteinbezogen werden zu können. 

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.2\textwidth]{bilder/Unity_Android}
	\caption{Mit Unity3D erstellte Spielszene unter Android}\label{game_unity}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.2\textwidth]{bilder/Cocos_iOS}
	\caption{Mit Cocos2D-X erstellte Spielszene unter iOS}\label{game_cocos}
\end{figure}

Die Abbildung \ref{game_unity} zeigt die Spielszene mit dem Android Testgerät, welche mit Unity3D erstellt wurde. Die Punktzahl ist noch nicht zu sehen, da die Spielfigur sich noch vor dem ersten Hindernis befindet. Die Framerate unten links wurde durch ein eigenes Script hinzugefügt. 
In Abbildung \ref{game_cocos} ist die gleiche Spielszene aus der Cocos2D-X Applikation unter iOS zu sehen. Die Unterschiede bei den Spielinhalten sind kaum auszumachen. Unten links wird die Framerate angezeigt, dessen Darstellung durch eine Standardfunktion zum debuggen ermöglicht wird.

\bigskip
\textbf{Ausgangsgröße einer Basisapplikation} \\
Die Ausgangsgröße einer Basisapplikation ist bei Android mit 8,12 MB bei libGDX am geringsten, jedoch bei iOS im Gegensatz dazu mit 48,9 MB am größten. Die geringe Größe bei Android liegt vor allem an der verwendeten Sprache Java, dass die Erstellung nahezu nativ behandelt. Wodurch sich die überdurchschnittliche Größe der Anwendung bei iOS zusammensetzt, konnte nicht genauer analysiert werden. RoboVM nutzt zwar Xcode indirekt für die Erzeugung und Installation der Applikation auf einem Gerät, generiert aber dabei kein ausführbares Xcode Projekt. Dadurch konnten Xcodes Analysewerkzeuge nicht verwendet werden.
Cocos2D-X besitzt bei beiden Plattformen einen geringen Speicherbedarf und kann sich in dieser Kategorie als der speichereffizienteste Kanditat hervortun.
Unity3D benötigt bei beiden Plattformen eine ähnliche Grundgröße.

\bigskip
\textbf{Gesamtgröße des Spiels} \\
Da die Applikation mit libGDX nicht finalisiert wurde, wird dieser Wert nur teilweise berücksichtigt. Durch die Aufaddierung der Ressourcen auf die Basisapplikation ist jedoch anzunehmen, dass sich die Steigerung des Speicherbedarfs bei fertiggestellter Anwendung nur geringfügig erhöht. Bei libGDX sowie Cocos2D-X ergeben sich die Gesamtgrößen der Applikationen scheinbar ausschließlich durch die Erweiterung der Ressourcen. Bei Unity3D war dies nicht der Fall. Die Vergrößerung der Android-App ist kleiner als die hinzugefügten Ressourcen, wodurch anzunehmen ist, dass die Spielelemente komprimiert werden. Anders ist es bei iOS, da hier die Vergrößerung etwa um die dreifache Ressourcengröße ausfällt. Cocos2D-X kann bei dieser Messkategorie, mit 19,7 MB bei Android und 13,9 MB bei iOS, als Sieger erklärt werden.


\bigskip
\textbf{Größe der Ressourcen} \\
Die Größen der Ressourcen sind bei libGDX und Cocos2D-X gleich, da bei beiden Frameworks die gleichen Elemente genutzt werden. Unity3Ds Ressourcengröße ist im Vergleich am geringsten, obwohl sich in diesem Ordner zusätzlich die geschriebenen Skripte und die gespeicherten Szenen befinden.

\bigskip
\textbf{Benötigter Arbeitsspeicher} \\
Die Reservierung des Arbeitsspeichers ist bei Unity3D am höchsten. Diesen Bereich kann Cocos2D-X ebenfalls für sich gewinnen, da der benötigte Arbeitsspeicher sehr gering ausfällt. Bei beiden Frameworks wird bei dem Android-Testgerät wesentlich mehr Arbeitsspeicher verwendet als bei dem iOS-Gerät. libGDX wird bei dieser Metrik nicht berücksichtigt. 


\bigskip
\textbf{Ladegeschwindigkeit bei Neustart} \\
Der Ladevorgang ist bei den beiden Open Source Frameworks sehr kurz. Unity3D benötigt auf dem iOS-Gerät mit etwa 7,5 Sekunden am längsten, jedoch kann die Ladegeschwindigkeit bei Android mit den beiden anderen Frameworks mithalten. Die Darstellung des Ladebildschirms wird bei der Unity3D Personal Edition jedoch erzwungen, was die Geschwindigkeit beeinflusst. Cocos2D-X ist in dieser Kategorie das schnellste Framework.


\bigskip
\textbf{Frames pro Sekunde} \\
Bei der Framerate konnten keine Daten für libGDX gesammelt werden, da die Implementierung der Darstellung nicht umgesetzt wurde. Cocos2D-X läuft auf beiden Plattformen mit stabilen 60 Frames pro Sekunde. Dies wird codeseitig festgelegt. Unity3D forciert das Testgerät standardmäßig zu keiner fest definierten Framerate, sondern passt diese der Leistung des Gerätes an. Das iOS Testgerät lief daher nur mit 30 Frames pro Sekunde. Es ist aber ebenfalls möglich, bei Unity3D eine Framerate vorzugeben. Alle Applikationen liefen jedoch flüssig und stabil, weshalb die Ergebnisse als gleichwertig angesehen werden.

\bigskip
\textbf{Akkuverbrauch} \\
Der Akkuverbrauch ergab keine aussagekräftigen Ergebnisse. Bei dem iOS-Gerät war überhaupt kein Leistungsabfall zu vermerken, ähnlich der Differenz bei dem Android-Gerät. Grund hierfür kann der zu geringe Umfang der Applikation sein, da diese modernere Smartphones kaum fordert.


\bigskip
\textbf{Mindestanforderung des Systems} \\
Auch bei den Mindestanforderungen gab es keine Differenzen. Alle Frameworks setzten die gleichen Mindestanforderungen voraus. Dies könnte ebenfalls mit der geringen technischen Anforderung einhergehen.

\bigskip
\textbf{Codezeilen} \\
Die Zeilenanzahl des geschriebenen Code ist bei Unity3D am geringsten, da die Funktionalität durch die umfangreiche Bibliothek kompakt ausgedrückt werden kann. Bei Cocos2D-X ist deutlich mehr Code erforderlich, was sich hauptsächlich durch die Sprache C++ und die zusätzlich benötigten Header-Dateien ergibt. libGDX wurde durch die Unvollständigkeit der App nicht mit aufgeführt. Es zeichnete sich jedoch ein Umfang ab, der ähnliche Ausmaße wie Cocos2D-X annahm.

\bigskip
In Tabelle \ref{protokoll_gesamt} wird das Gesamtergebnis dargestellt, wobei das jeweils beste Spielefamework einer Metrik durch ein X markiert ist. Diese Bewertung ergibt sich aus den zusammengenommenen Ergbnissen beider Plattformen. Auch wenn libGDX nur teilweise berücksichtigt wurde, konnte es in der Gesamtwertung keinen eindeutigen Vorteil verzeichnen. Mit sechs gewonnenen Kategorien kann sich Cocos2D-X im Gebiet der Effizienz und Ausführungsgeschwindigkeit vor der Konkurrenz behaupten. 

\begin{table}[htbp]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{cccc}
			\rowcolor[HTML]{000000} 
			\multicolumn{4}{c}{\cellcolor[HTML]{000000}{\color[HTML]{FFFFFF} \textbf{Gesamtergebnis}}}                                                                                                                                                                                 \\
			\rowcolor[HTML]{000000} 
			\multicolumn{4}{l}{\cellcolor[HTML]{000000}{\color[HTML]{000000} }}                                                                                                                                                                                                              \\
			\rowcolor[HTML]{000000} 
			{\color[HTML]{FFFFFF} \textbf{Metrik}}                                                                     & {\color[HTML]{FFFFFF} \textbf{libGDX}} & {\color[HTML]{FFFFFF} \textbf{Cocos2D}} & {\color[HTML]{FFFFFF} \textbf{Unity3D}} \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ausgangsgröße \\ einer Basisapplikation\end{tabular}}} & \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Gesamtgröße \\ des Spiels\end{tabular}}}            & \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Größe der Ressourcen}}                                                         &  \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{}                   & \multicolumn{1}{c|}{\textbf{X}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Benötigter Arbeitsspeicher}}                                                   &  \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Ladegeschwindigkeit \\ bei Neustart\end{tabular}}}  &  \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Frames pro Sekunde}}                                                            & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{\textbf{X}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Akkuverbrauch}}                                                                & \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{}                   & \multicolumn{1}{c|}{}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Mindestanforderung des Systems}}                                                                             &  \multicolumn{1}{c|}{\textbf{}}                  & \multicolumn{1}{c|}{\textbf{X}}                   & \multicolumn{1}{c|}{\textbf{X}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Codezeilen}}                                                                             & \multicolumn{1}{c|}{-}                  & \multicolumn{1}{c|}{}                   & \multicolumn{1}{c|}{\textbf{X}}                   \\ \hline
			\multicolumn{1}{|c|}{\textbf{Ergebnis}}                                                                             & \multicolumn{1}{c|}{}                  & \multicolumn{1}{c|}{\textbf{6}}                   & \multicolumn{1}{c|}{\textbf{4}}                   \\ \hline
		\end{tabular}
	}
	\caption{Gesamtergebnis anhand der Messerergebnisse}\label{protokoll_gesamt}
\end{table}

%\caption{Messprotokoll des Spiels auf Android}\label{protokoll_android}
%Kosten, Performance, Akkuverbrauch, App-Daten-Aufteilung, Größe des benötigten Speichers, Größe des geteilten Contents, Stabilität, RAM, Code-Zeilen/-Größe, Entwicklungszeit(bedingt zu berücksichtigen), FPS

\chapter{Vergleich zur Benutzbarkeit}
In diesem Kapitel werden die Erfahrungen wiedergegeben, die während des Implementierungsprozess gewonnen wurden.

\bigskip
Durch die in Kapitel \ref{sec:analyse_der_apps} durchgeführte Messung und darauf folgende Auswertung stellte sich heraus, dass mit Cocos2D-X sehr effiziente Resultate erzielt werden können. Bei beiden Zielplattformen konnten kurze Ladezeiten, geringer Speicherbedarf und effektive Kompilierung ohne stark anwachsende Datenmengen beobachtet werden. Das Ergebnis wird allerdings zu Lasten von einer vergleichsweise umfangreicheren Einarbeitungszeit und ebenso intensiven Testphasen beeinflusst. Bei der Einarbeitung wurden durch die offizielle Dokumentation verständliche Erklärungen und Hilfen für die beste Vorgehensweise bereitgestellt. Die Sprache C++ spielt seine Vorteile als Basis für die Spieleentwicklung in der umgesetzten Beispielapplikation voll aus. Jedoch sind für erfolgreiche und stabile Resultate längere Entwicklungszeiten und fortgeschrittene Erfahrungswerte notwendig sowie der sichere Umgang mit dieser Sprache.

\bigskip
Während der Entwicklungszeit wurden die zuvor hohen Erwartungen an libGDX stark getrübt. Obwohl die Entwicklung der Android Applikation vergleichsweise die effizientesten Messergebnisse ergeben hat, waren die Ergebnisse bei iOS genau komplementär. Der Vorteil der Modularität wirkt sich bei mobilen Anwendungen demnach nur bei Android aus. Auch die Kompilierung mit RoboVM zu iOS ist befremdlich, da kein Xcode Projekt erzeugt wird und das Resultat dadurch nicht ausreichend kontrolliert werden kann. Es konnten aus der IDE auch keine Paketdateien (apk/ipa) mit libGDX erstellt werden. Diese Erkenntnisse stellen den Nutzen der plattformübergreifenden Eigenschaften im Mobilbereich in Frage. Während der Entwicklung traten zudem verschiedene Hürden in Erscheinung, die dem Fortschritt unnötig im Weg standen. Die Dokumentation macht anfänglich einen guten und umfangreichen Eindruck, jedoch stieß man bei der Suche nach Umsetzungsmöglichkeiten von scheinbar einfachen Anforderungen schnell an die Grenzen. Für die Realisierung geeigneter Physik und Kollisionsabfragen bei 2D Spielen wird in der Dokumentation das externe Framework Box2D vorgeschlagen, welches auch bei Cocos2D-X eingesetzt wurde. libGDX stellt dafür aber keine eigene Anleitung und verweist für die richtige Verwendung auf die Dokumentation von Box2D, welche allerdings nur Erklärungen für die Anwendung mit C++ bereitstellt. Auch die Einbindung von üblichen Schriftarten, wie TrueType Fonts, ist nicht möglich. Schrift innerhalb von Anwendungen wird bei libGDX durch pixelbasierte Bitmap-Schriften realisiert, die bei unterschiedlichen Bildschirmgrößen unschöne und unscharfe Skalierungen auslösen. Die Verwendung von libGDX zur Entwicklung von plattformübergreifenden, mobilen Spielen ist aufgrund der genannten Defizite nur bei gezielten Anforderungen ratsam. 

\bigskip
Die Ergebnisse der Applikationen durch die Engine Unity3D scheinen auf den ersten Blick moderat auszufallen. Im Bereich der Speicherverwendung wird eine höhere Grundgröße beansprucht, die aber durch den Einsatz von zusätzlichen Ressourcen und Hinzufügen von Komplexitäten verhältnismäßig gering zunimmt. Die Anwendungen laufen stabil und fehlerfrei. Die vorherige Erwartung einer umfangreichen Einarbeitungszeit konnte während der Entwicklung widerlegt werden. Umgang und Arbeit mit dem Editor sind intuitiv zu verstehen und verständlich aufgebaut. Die erforderliche Logik konnte mit Hilfe der unterstützten IDEs in kurzer Zeit umgesetzt, im Editor getestet und angepasst werden. Durch die Möglichkeit, den Entwicklungsstand innerhalb des Editors zu testen und während der Laufzeit Anpassungen vorzunehmen, konnte effektiv und zielgerichtet gearbeitet werden. Bei auftretenden Fehlern während der Tests wurde zudem sofort auf die richtige Codezeile innerhalb des Scripts verwiesen. Der Gebrauch von Prefabs für die Mehrfachverwendung von wiederkehrenden Spielinhalten erwies sich als komfortabel und effizient. Durch die umfangreiche Dokumentation mit vielen Anwendungsbeispielen und Tutorials sind Momente der Ratlosigkeit von kurzer Dauer. Die Kompilierung zu den Zielplattformen wurde problemlos durchgeführt und ergab auf den Testgeräten das durch den Editor vorausgesetzte Ergebnis. Der Gebrauch von Unity3D für die Erstellung von plattformübergreifenden, mobilen Spielen ist durch die hohe Entwicklungsgeschwindigkeit und die Abdeckung aller denkbaren spielebasierten Anforderungen durchaus empfehlenswert.


%TODO
\chapter{Fazit}
Cocos2D-X und Unity3D lieferten bei der Implementierung und der anschließenden Messung äußerst zufriedenstellende Ergebnisse. Cocos2D-X bietet das höchste Potential bei der Performance von Anwendungen und kann sich der Unterstützung einer umfangreichen Community erfreuen, die sich um die stetige, zeitgemäße Weiterentwicklung bemüht. Bei Spielen mit einfachen Anforderungen und geringem Inhalt kann sich Cocos2D-X gut präsentieren. Bei steigendem Umfang mit ausgedehnter Komplexität und vielfältigen Inhalten kann die effiziente Entwicklung mit diesem Framework aber nur durch erheblichen Aufwand umgesetzt werden. Dadurch sind ökonomische, plattformübergreifende Entwicklungsprozesse zwar dennoch möglich, aber eher Entwicklern mit reichhaltiger Erfahrung vorbehalten.

\bigskip
libGDX bietet zwar für die meisten Bedingungen eine externe Schnittstellenlösung an, stellt diese aber nicht ausreichend an das eigene Framework angepasst zur Verfügung. Dadurch verlieren viele dieser Schnittstellen ihre Zweckmäßigkeit, wenn sie nur aus Gründen der Vollständigkeit eingebunden werden, ohne aber sorgfältig verwaltet zu werden.

\bigskip
Unity3D ergab bei der Analyse der Applikation scheinbar durchschnittliche Ergebnisse, welche von dieser aber stabil und effizient ausgeführt wurden. Die kurze Einarbeitungszeit, die schnelle Erstellung von zweckmäßigen Resultaten sowie die vielseitigen Unterstützungen und Hilfestellungen sind ein immenser ökonomischer Vorteil, den Privatnutzer, Indieentwickler und professionelle Studios für sich nutzen können. Unity3D bietet zudem die umfangreichsten Schnittstellen zu externen Services und Gerätefunktionen sowie die größte Menge an unterschiedlichen Zielplattformen in allen Kategorien. Daher kann die Behauptung aufgestellt werden, dass es kaum Anforderungen an die Realisierung eines digitalen, mobilen Spiels gibt, die ein Hindernis für die Engine Unity3D darstellt. Somit kann sich dieses Spieleframework als vielseitiger, intuitiver und innovativer Alleskönner behaupten, dessen zunehmende Verbreitung sich durchaus rechtfertigt.




%--------------------- VERZEICHNISSE -------------------------------------

\listoffigures % Abbildungsverzeichnis erzeugen
\listoftables % Tabellenverzeichnis erzeugen

%------------------------------ LITERATURVERZEICHNIS----------------------
%TODO:Alphabetisch sortieren! ECKIGE Klammern wegnehmen
\begin{thebibliography}{}
	
\bibitem[AndEngine(2013)]{andEngine}
AndEngine (2013): \emph{Free Android 2D OpenGL Game Engine},
\url{https://github.com/nicolasgramlich/AndEngine}, letzter Zugriff: 28.12.2015

\bibitem[Android Develop Tools(2015)]{android_studio}
Android Develop Tools (2015): \emph{Android Studio Overview},
\url{http://developer.android.com/tools/studio/index.html}, letzter Zugriff: 24.11.2015

\bibitem[Android Source - Codenames, Tags, and Build Numbers(2015)]{android_codenames}
Android Source - Codenames, Tags, and Build Numbers (2015):
\emph{Codenames, Tags, and Build Numbers in the history of Android},
\url{https://source.android.com/source/build-numbers.html}, letzter Zugriff: 24.11.2015

\bibitem[App42(2016)]{app42}
App42 (2016): \emph{App42 Cloud API},
\url{http://api.shephertz.com/}, letzter Zugriff: 01.02.2016

\bibitem[AppGameKit(2015)]{appgamekit}
AppGameKit (2015): \emph{AppGameKit - Platforms \& Features},
\url{http://www.appgamekit.com/platforms-and-features.php}, letzter Zugriff: 18.02.2016

\bibitem[Apple Developer(2015)a]{swift_about}
Apple Developer (2015)a: \emph{Swift - Overview},
\url{https://developer.apple.com/swift/}, letzter Zugriff: 28.12.2015

\bibitem[Apple Developer(2016)b]{apple_developer_program}
Apple Developer (2016)b: \emph{How the Program Works},
\url{https://developer.apple.com/programs/how-it-works/}, letzter Zugriff: 15.02.2016

\bibitem[Berkman(2012)]{microsoft_mobile}
Berkman (2012): Berkman, Fran \emph{Microsoft Mobile: From Pocket PC to Windows Phone 8},
\url{http://mashable.com/2012/10/29/microsoft-mobile-history/#DYxZxZ7wTuqD}, letzter Zugriff: 25.11.2015

\bibitem[Boo(2015)]{boo_about}
Boo (2015): \emph{Boo - A scarily powerful language for .NET},
\url{http://boo-language.github.io/}, letzter Zugriff: 05.01.2016

\bibitem[Brown(2015)]{learning_javascript}
Brown (2015): Brown, Ethan (Hrsg.): 
\emph{Learning Javascript}, O'Reilly 2015

\bibitem[C++(2016)]{cplusplus}
C++ (2016): \emph{C++ - A Brief Description},
\url{http://www.cplusplus.com/info/description/}, letzter Zugriff: 05.01.2016

\bibitem[Cocos2D-Android(2010)]{cocos2d_android}
Cocos2D-Android (2010): \emph{cocos2d for Android: A framework for building 2D games for the Android platform},
\url{https://code.google.com/archive/p/cocos2d-android/}, letzter Zugriff: 28.12.2015

\bibitem[Cocos2D-iPhone(2015)]{cocos2d_iphone}
Cocos2D-iPhone (2015): \emph{Cocos2D - ObjC Site},
\url{http://www.cocos2d-iphone.org/}, letzter Zugriff: 28.12.2015

\bibitem[Cocos2D-X(2015)a]{cocos2d_main_features}
Cocos2D-X (2015)a: \emph{Cocos2D-X - Developers Manual},
\url{http://www.cocos2d-x.org/wiki/Cocos2d-x}, letzter Zugriff: 29.12.2015

\bibitem[Cocos2D-X(2015)b]{cocos2d_relationships}
Cocos2D-X (2015)b: \emph{Cocos2D-X - Relationships in Cocos2D Family},
\url{http://www.cocos2d-x.org/wiki/Relationships_in_Cocos2d_Family}, letzter Zugriff: 05.01.2016

\bibitem[Cocos2D-X(2015)c]{cocos2d_docs}
Cocos2D-X (2015)c: \emph{Cocos2D-X - Dokumentation},
\url{http://www.cocos2d-x.org/reference/native-cpp/V3.9/index.html}, letzter Zugriff: 10.01.2016

\bibitem[Daintith(2004)]{native_software}
Daintith (2004): Daintith, John: \emph{A Dictionary of Computing - native software},
\url{http://www.encyclopedia.com/doc/1O11-nativesoftware.html}, letzter Zugriff: 24.11.2015

\bibitem[Distimo(2014)]{play_store_categories}
Distimo (2014): \emph{Anteil der im Google Play Store weltweit am häufigsten heruntergeladenen Apps nach Kategorien im Februar 2014. In Statista - Das Statistik-Portal.},
\url{http://de.statista.com/statistik/daten/studie/321703/umfrage/beliebteste-app-kategorien-im-google-play-store-weltweit/}, letzter Zugriff: 14.12.2015

\bibitem[El-Kassas, Wafaa S. \& Abdullah, Bassem A. \&  Yousef, Ahmed H. \&  Wahba, Ayman M.(2015)]{cross_plattform_approaches} 
El-Kassas, Wafaa S. \& Abdullah, Bassem A. \&  Yousef, Ahmed H. \&  Wahba, Ayman M. :
\glqq Taxonomy of Cross-Platform Mobile Applications Development Approaches\grqq, 
\emph{Ain Shams Engineering Journal}, 2015

\bibitem[Golem(2015)]{wp_with_android_ios}
Golem (2015): \emph{Microsoft demonstriert Android- und iOS-Apps unter Windows},
\url{http://www.golem.de/news/windows-10-microsoft-demonstriert-android-und-ios-apps-unter-windows-1504-113812.html}, letzter Zugriff: 25.11.2015

\bibitem[Hölzl \& Raed \& Wirsing(2013)]{java_kompakt}
Hölzl, Matthias \& Raed, Allaithy \& Wirsing, Martin (Hrsg.): 
\emph{Java kompakt Eine Einführung in die Software-Entwicklung
	mit Java}, Springer 2013

\bibitem[IDC(2015)]{marktanteile_betriebssysteme}
IDC (2015): \emph{Prognose zu den Marktanteilen der Betriebssysteme am Absatz vom Smartphones weltweit in den Jahren 2015 und 2019. In Statista - Das Statistik-Portal.},
\url{http://de.statista.com/statistik/daten/studie/182363/umfrage/prognostizierte-marktanteile-bei-smartphone-betriebssystemen/}, letzter Zugriff: 14.12.2015

\bibitem[JetBrains(2015)]{appcode}
JetBrains (2015): \emph{JetBrains AppCode},
\url{https://www.jetbrains.com/objc/}, letzter Zugriff: 28.12.2015

\bibitem[jPCT-AE(2015)]{jpct_ae}
jPCT-AE (2015): \emph{jPCT 3D engine - the free 3D solution for Java and Android},
\url{http://www.jpct.net/jpct-ae/index.html}, letzter Zugriff: 28.12.2015

\bibitem[Junge(2015)]{ludologie}
Junge (2015): Junge, Prof. Dr. Jens:
\emph{Zur Begriffsklärung von Ludologie und Spielwissenschaft},
\url{http://www.ludologie.de/neues-spiel/detailansicht/news/detail/News/zur-begriffsklaerung-von-ludologie-und-spielwissenschaft/}, letzter Zugriff: 28.01.2016

\bibitem[Kantar(2015)]{marktanteile_betriebssysteme_laender}
Kantar (2015): \emph{Marktanteile der mobilen Betriebssysteme am Absatz von Smartphones in ausgewählten Ländern von August bis Oktober 2015. In Statista - Das Statistik-Portal.},
\url{http://de.statista.com/statistik/daten/studie/198453/umfrage/marktanteile-der-smartphone-betriebssysteme-am-absatz-in-ausgewaehlten-laendern/}, letzter Zugriff: 14.12.2015

\bibitem[libGDX(2013)a]{libGDX_main_features}
libGDX (2013)a: \emph{libGDX - Goals and Features},
\url{https://libgdx.badlogicgames.com/features.html}, letzter Zugriff: 29.12.2015

\bibitem[libGDX(2013)b]{libGDX_docs}
libGDX (2013)b: \emph{libGDX API},
\url{https://libgdx.badlogicgames.com/nightlies/docs/api/}, letzter Zugriff: 10.01.2016

\bibitem[libGDX(2015)c]{libGDX_wiki}
libGDX (2015)c: \emph{libGDX - Setting up your Development Environment (Eclipse, Intellij IDEA, NetBeans)},
\url{https://github.com/libgdx/libgdx/wiki/Setting-up-your-Development-Environment-(Eclipse,-Intellij-IDEA,-NetBeans)}, letzter Zugriff: 18.02.2016

\bibitem[Lua(2015)]{lua_about}
Lua (2015): \emph{Lua - About},
\url{http://www.lua.org/about.html}, letzter Zugriff: 05.01.2016

\bibitem[Lumberyard(2016)]{lumberyard}
Lumberyard (2016): \emph{Lumberyard Beta - Details},
\url{https://aws.amazon.com/de/lumberyard/details/}, letzter Zugriff: 18.02.2016

\bibitem[Mac Developer Library(2014)]{objectiveC_about}
Mac Developer Library (2014): \emph{About Objective-C},
\url{https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html/}, letzter Zugriff: 28.12.2015

\bibitem[MacinCloud(2015)]{macincloud}
MacinCloud (2015): \emph{MacinCloud},
\url{http://www.macincloud.com/}, letzter Zugriff: 28.12.2015

\bibitem[MacLeod(2014)]{macLeod}
MacLeod (2014): MacLeod, Kevin:
\emph{Monkeys Spinning Monkeys},
Licensed under Creative Commons: By Attribution 3.0
http://creativecommons.org/licenses/by/3.0/
\url{http://incompetech.com/music/royalty-free}, letzter Zugriff: 28.01.2016

\bibitem[Microsoft Developer(2015)]{WP10_SDK}
Microsoft Developer (2015): \emph{Windows Software Development Kit (SDK) for Windows 10},
\url{https://dev.windows.com/en-us/downloads/windows-10-sdk}, letzter Zugriff: 28.12.2015

\bibitem[Microsoft(2014)a]{microsoft_nokia}
Microsoft (2014)a: \emph{Microsoft - Microsoft und Nokia Geräte},
\url{https://www.microsoft.com/de-de/nokia.aspx}, letzter Zugriff: 25.11.2015

\bibitem[Microsoft(2015)b]{windows10_features}
Microsoft (2015)b: \emph{Microsoft - Windows 10 Features},
\url{https://www.microsoft.com/de-de/windows/features}, letzter Zugriff: 25.11.2015

\bibitem[MonoGame(2016)]{monogame}
MonoGame (2016): \emph{MonoGame - About},
\url{http://www.monogame.net/about/}, letzter Zugriff: 18.02.2016

\bibitem[MSDN(2015)]{WP10_Emulator}
MSDN (2015): \emph{Microsoft-Emulator für Windows 10 Mobile},
\url{https://msdn.microsoft.com/library/windows/apps/mt162269.aspx}, letzter Zugriff: 28.12.2015

\bibitem[Nextpeer(2016)]{nextpeer}
Nextpeer (2016): \emph{Nextpeer},
\url{https://www.nextpeer.com/}, letzter Zugriff: 01.02.2016

\bibitem[Open Handset Alliance - Alliance Members(2015)]{alliance_members}
Open Handset Alliance - Alliance Members (2015): \emph{Members of the Open Handset Alliance},
\url{http://www.openhandsetalliance.com/oha_members.html}, letzter Zugriff: 24.11.2015

\bibitem[Open Handset Alliance - Alliance Overview(2015)]{alliance_overview}
Open Handset Alliance - Alliance Overview (2015): \emph{Overview of the Open Handset Alliance},
\url{http://www.openhandsetalliance.com/oha_overview.html}, letzter Zugriff: 24.11.2015

\bibitem[Open Handset Alliance - Android Overview(2015)]{android_overview}
Open Handset Alliance - Android Overview (2015): \emph{Overview of Android by the Open Handset Alliance},
\url{http://www.openhandsetalliance.com/android_overview.html}, letzter Zugriff: 24.11.2015

\bibitem[Oracle - Java SE(2015)]{java_jdk}
Oracle - Java SE (2015): \emph{Java SE Development Kit 8 Downloads},
\url{http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html}, letzter Zugriff: 24.11.2015

\bibitem[Piskel(2015)]{piskel}
Piskel (2015): \emph{Piskel - Pixel Art and Animated Sprites},
\url{http://www.piskelapp.com/}, letzter Zugriff: 28.01.2016

\bibitem[Play Game Services(2015)]{play_game_services}
Play Game Services (2015): \emph{Play Games Services},
\url{https://developers.google.com/games/services/}, letzter Zugriff: 01.02.2016

\bibitem[PocketGamer.biz(2015)]{app_store_categories}
PocketGamer.biz (2015): \emph{Ranking der Top-20-Kategorien im App Store im Dezember 2015. In Statista - Das Statistik-Portal.},
\url{http://de.statista.com/statistik/daten/studie/166976/umfrage/beliebteste-kategorien-im-app-store/}, letzter Zugriff: 15.12.2015

\bibitem[RoboVM(2016)]{roboVM}
RoboVM (2016): \emph{RoboVM - Create truly native iOS apps in Java},
\url{https://robovm.com/}, letzter Zugriff: 15.02.2016

\bibitem[Salen \& Zimmerman(2004)]{salen_zimmerman}
Salen \& Zimmerman (2004): Salen, Katie \& Zimmerman, Eric: 
\glqq Unit 1: Core Concepts: Defining Games\grqq, 
(Hrsg.): \emph{Rules of Play: Game Design Fundamentals}, The MIT Press 2004

\bibitem[Schmidt(2015)]{java_9}
Schmidt (2015): Schmidt, Julia: \emph{heise Developer - Java 9: Pläne für Release im Herbst 2016},
\url{http://www.heise.de/developer/meldung/Java-9-Plaene-fuer-Release-im-Herbst-2016-2635526.html}, letzter Zugriff: 06.01.2016

\bibitem[Skeet(2014)]{csharp_in_depth}
Skeet (2014): Skeet, Jon (Hrsg.): 
\emph{C\# in Depth}, Manning 2014

\bibitem[Smith(2013)]{android_sdk_requirements}
Smith (2013): Smith, Sue \emph{Android SDK Requirements},
\url{http://code.tutsplus.com/tutorials/android-sdk-requirements--mobile-20086}, letzter Zugriff: 24.11.2015

\bibitem[Sparrow(2015)]{sparrow}
Sparrow (2015): \emph{Sparrow - The Open Source Game Engine for iOS},
\url{http://gamua.com/sparrow/}, letzter Zugriff: 28.12.2015

\bibitem[SpriteKit(2015)]{about_spritekit}
SpriteKit (2015): \emph{iOS Developer Library - About SpriteKit},
\url{https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html}, letzter Zugriff: 28.12.2015

\bibitem[Statista(2015)]{apps_in_stores}
Statista (2015): \emph{Anzahl der angebotenen Apps in den Top App-Stores im Mai 2015. In Statista - Das Statistik-Portal.},
\url{http://de.statista.com/statistik/daten/studie/208599/umfrage/anzahl-der-apps-in-den-top-app-stores/}, letzter Zugriff: 14.12.2015

\bibitem[t3n(2015)]{t3n_xcode7}
t3n (2015): \emph{Xcode 7: Apps auch ohne Entwickler-Account auf dem iPhone testen},
\url{http://t3n.de/news/xcode-7-apps-ohne-615214/}, letzter Zugriff: 28.12.2015

\bibitem[techopedia(2015)]{cross_plattform_explanation}
techopedia (2015): \emph{Cross-Platform Development},
\url{https://www.techopedia.com/definition/30026/cross-platform-development}, letzter Zugriff: 21.12.2015

\bibitem[the iphone wiki(2015)]{ios_codenames}
the iphone wiki (2015): \emph{iOS Firmwares},
\url{https://www.theiphonewiki.com/wiki/Firmware}, letzter Zugriff: 24.11.2015

\bibitem[Unify Community Wiki(2014)]{unity_unityscript_vs_javascript}
Unify Community Wiki (2014): \emph{Unify Community Wiki - UnityScript versus JavaScript},
\url{http://wiki.unity3d.com/index.php/UnityScript_versus_JavaScript}, letzter Zugriff: 05.01.2016

\bibitem[Unity3D(2014)d]{unity_languages}
Unity3D (2014)d: \emph{Unity3D - Documentation, Unity scripting languages and you},
\url{http://blogs.unity3d.com/2014/09/03/documentation-unity-scripting-languages-and-you/}, letzter Zugriff: 05.01.2016

\bibitem[Unity3D(2015)a]{unity_public_relations}
Unity3D (2015)a: \emph{Unity3D - Public Relations},
\url{https://unity3d.com/public-relations}, letzter Zugriff: 29.12.2015

\bibitem[Unity3D(2015)b]{unity_managed_plugins}
Unity3D (2015)b: \emph{Unity3D Documentation - Managed Plugins},
\url{http://docs.unity3d.com/Manual/UsingDLL.html}, letzter Zugriff: 05.01.2016

\bibitem[Unity3D(2015)c]{unity_products}
Unity3D (2015)c: \emph{Unity3D - Get Unity},
\url{http://unity3d.com/get-unity}, letzter Zugriff: 05.01.2016

\bibitem[Unity3D(2015)d]{unity_docs}
Unity3D (2015)d: \emph{Unity3D - Scripting API},
\url{http://docs.unity3d.com/ScriptReference/index.html}, letzter Zugriff: 10.01.2016

\bibitem[Unity3D(2016)e]{unity_code_editor}
Unity3D (2016)e: \emph{Unity3D - Tutorials: Scripting},
\url{https://unity3d.com/learn/tutorials/topics/scripting}, letzter Zugriff: 10.02.2016

\bibitem[Vehse(2014)]{cross_plattform_development_vehse} 
Vehse (2014): Vehse, Benjamin:
\glqq Plattformabhängige und –unabhängige
Entwicklung mobiler Anwendungen am
Beispiel von Geo-Wikipedia-App\grqq, 
\emph{Bachelor-Thesis}, 2014

\bibitem[Visual Studio(2016)]{visual_studio}
Visual Studio (2016): \emph{Visual Studio - Tools für alle Entwickler und alle Apps},
\url{https://www.visualstudio.com/de-de/dn469161}, letzter Zugriff: 15.02.2016

\bibitem[Whitcomb Riley(1849–1916)]{ducktest}
Whitcomb Riley (1849–1916): Whitcomb Riley, James \emph{Ententest - Begriffsentstehung},
\url{https://de.wikipedia.org/wiki/Ententest}, letzter Zugriff: 05.01.2016

\bibitem[Wikipedia - Apple iOS(2015)]{apple_ios}
Wikipedia - Apple iOS (2015): \emph{Apple iOS},
\url{https://de.wikipedia.org/wiki/Apple_iOS}, letzter Zugriff: 24.11.2015

\bibitem[Wikipedia - Flappy Bird(2015)]{flappy_bird}
Wikipedia - Flappy Bird (2015): \emph{Flappy Bird},
\url{https://de.wikipedia.org/wiki/Flappy_Bird}, letzter Zugriff: 28.01.2016

\bibitem[Wikipedia - List of game engines(2016)]{list_of_game_engines}
Wikipedia - List of game engines (2016): \emph{List of game engines(2016)},
\url{https://en.wikipedia.org/wiki/List_of_game_engines}, letzter Zugriff: 23.02.2016

\bibitem[Wikipedia - Liste von Android-Versionen(2015)]{android_version_releases}
Wikipedia - Liste von Android-Versionen (2015): \emph{Übersicht von allen Android Versionen mit Veröffentlichungsdatum},
\url{https://de.wikipedia.org/wiki/Liste_von_Android-Versionen}, letzter Zugriff: 24.11.2015

\bibitem[Wikipedia - Windows 10(2015)]{WP10_version_releases}
Wikipedia - Windows 10 (2015): \emph{Microsoft Windows 10 Mobile},
\url{https://de.wikipedia.org/wiki/Microsoft_Windows_10_Mobile}, letzter Zugriff: 28.12.2015

\bibitem[Wikipedia - Windows Phone 7(2015)]{WP7_version_releases}
Wikipedia - Windows Phone 7 (2015): \emph{Microsoft Windows Phone 7},
\url{https://de.wikipedia.org/wiki/Microsoft_Windows_Phone_7}, letzter Zugriff: 28.12.2015

\bibitem[Wikipedia - Windows Phone 8(2015)]{WP8_version_releases}
Wikipedia - Windows Phone 8 (2015): \emph{Microsoft Windows Phone 8},
\url{https://de.wikipedia.org/wiki/Microsoft_Windows_Phone_8}, letzter Zugriff: 28.12.2015

\bibitem[XMLVM(2011)]{XMLVM_Toolchain}
XMLVM (2011): \emph{XMLVM - Overview: Toolchain},
\url{http://xmlvm.org/toolchain/}, letzter Zugriff: 25.12.2015

\bibitem[XNA(2015)]{xna}
XNA (2015): \emph{Microsoft Developer Network - XNA Game Studio 4.0},
\url{https://msdn.microsoft.com/de-de/library/bb200104(v=xnagamestudio.40).aspx}, letzter Zugriff: 28.12.2015

\bibitem[YoYo Games(2013)]{WP8_requirements}
YoYo Games (2013): \emph{Requirements for Windows Phone development},
\url{http://help.yoyogames.com/entries/23355146-Requirements-for-Windows-Phone-development}, letzter Zugriff: 28.12.2015

\bibitem[Zamora(2015)]{windows_store_trends_2015}
Zamora (2015): Zamora, Bernardo: \emph{Blogs.Windows - Windows Store Trends - September 2015},
\url{https://blogs.windows.com/buildingapps/2015/10/12/windows-store-trends-september-2015/}, letzter Zugriff: 15.12.2015

\end{thebibliography}
%----------------------------- EIGENSTÄNDIGKEITSERKLÄRUNG-----------------
\clearpage\thispagestyle{empty}
\eigen  % im header definiert
%----------------------------- ENDE --------------------------------------
\end{document}